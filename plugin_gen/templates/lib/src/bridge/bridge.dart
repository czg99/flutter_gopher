// Code generated by flutter_gopher. DO NOT EDIT.
// ignore_for_file: unused_element
import 'dart:async';
import 'dart:convert';
import 'dart:ffi' as ffi;
import 'dart:isolate';
import 'dart:typed_data';
import 'package:ffi/ffi.dart';
import 'loader.dart';

typedef FgBridgeMethodHandle = void Function(int method, Uint8List data);

class FgBridgeException implements Exception {
  final String message;

  const FgBridgeException(this.message);

  @override
  String toString() => 'FgBridgeException: $message';
}

class FgBridge {
  static final _api = _bridge();

  static FgBridgeMethodHandle? methodHandle;

  FgBridge._();

  static void init() => _api;

  static void setMethodHandle(FgBridgeMethodHandle handle) {
    _api;
    methodHandle = handle;
  }

  static Uint8List callGoMethod(int method, {Uint8List? data}) => _api.callGoMethod(method, data: data);
  static Future<Uint8List> callGoMethodAsync(int method, {Uint8List? data}) =>
      _api.callGoMethodAsync(method, data: data);

  static Uint8List callPlatformMethod(int method, {Uint8List? data}) => _api.callPlatformMethod(method, data: data);
  static Future<Uint8List> callPlatformMethodAsync(int method, {Uint8List? data}) =>
      _api.callPlatformMethodAsync(method, data: data);
}

final _lib = FgLoader('{{.LibName}}');
final void Function(ffi.Pointer<ffi.Void>, int) _fgInitDartApi = _lib
    .lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>('fg_init_dart_api_{{.Timestamp}}')
    .asFunction();
final _fgResponse Function(_fgRequest) _fgCallGoMethod = _lib
    .lookup<ffi.NativeFunction<_fgResponse Function(_fgRequest)>>('fg_call_go_method_{{.Timestamp}}')
    .asFunction();
final void Function(int, _fgRequest) _fgCallGoMethodAsync = _lib
    .lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, _fgRequest)>>('fg_call_go_method_async_{{.Timestamp}}')
    .asFunction();
final _fgResponse Function(_fgRequest) _fgCallPlatformMethod = _lib
    .lookup<ffi.NativeFunction<_fgResponse Function(_fgRequest)>>('fg_call_platform_method_{{.Timestamp}}')
    .asFunction();
final void Function(int, _fgRequest) _fgCallPlatformMethodAsync = _lib
    .lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64, _fgRequest)>>(
      'fg_call_platform_method_async_{{.Timestamp}}',
    )
    .asFunction();

class _bridge {
  _bridge() {
    final receivePort = ReceivePort();
    receivePort.listen((addr) {
      final requestPtr = ffi.Pointer.fromAddress(addr).cast<_fgRequest>();
      final (method, data) = _mapFromFgRequest(requestPtr[0]);
      malloc.free(requestPtr);

      if (FgBridge.methodHandle != null) {
        FgBridge.methodHandle!(method, data);
      }
    });
    _fgInitDartApi(ffi.NativeApi.initializeApiDLData, receivePort.sendPort.nativePort);
  }

  Uint8List callGoMethod(int method, {Uint8List? data}) {
    final request = _mapToFgRequest(method, data ?? Uint8List(0));
    final response = _fgCallGoMethod(request);
    final (result, error) = _mapFromFgResponse(response);
    if (error != null) {
      throw FgBridgeException(error);
    }
    return result;
  }

  Future<Uint8List> callGoMethodAsync(int method, {Uint8List? data}) async {
    final receivePort = ReceivePort();
    final request = _mapToFgRequest(method, data ?? Uint8List(0));
    _fgCallGoMethodAsync(receivePort.sendPort.nativePort, request);
    final responseAddr = await receivePort.first;
    final responsePtr = ffi.Pointer.fromAddress(responseAddr).cast<_fgResponse>();

    final (result, error) = _mapFromFgResponse(responsePtr[0]);
    malloc.free(responsePtr);
    if (error != null) {
      throw FgBridgeException(error);
    }
    return result;
  }

  Uint8List callPlatformMethod(int method, {Uint8List? data}) {
    final request = _mapToFgRequest(method, data ?? Uint8List(0));
    final response = _fgCallPlatformMethod(request);
    final (result, error) = _mapFromFgResponse(response);
    if (error != null) {
      throw FgBridgeException(error);
    }
    return result;
  }

  Future<Uint8List> callPlatformMethodAsync(int method, {Uint8List? data}) async {
    final receivePort = ReceivePort();
    final request = _mapToFgRequest(method, data ?? Uint8List(0));
    _fgCallPlatformMethodAsync(receivePort.sendPort.nativePort, request);
    final responseAddr = await receivePort.first;
    final responsePtr = ffi.Pointer.fromAddress(responseAddr).cast<_fgResponse>();

    final (result, error) = _mapFromFgResponse(responsePtr[0]);
    malloc.free(responsePtr);
    if (error != null) {
      throw FgBridgeException(error);
    }
    return result;
  }
}

final class _fgData extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;
  @ffi.Int()
  external int size;
}

final class _fgRequest extends ffi.Struct {
  @ffi.Int()
  external int method;
  external _fgData data;
}

final class _fgResponse extends ffi.Struct {
  external _fgData data;
  external _fgData error;
}

_fgRequest _mapToFgRequest(int method, Uint8List data) {
  final result = ffi.Struct.create<_fgRequest>();
  result.method = method;
  result.data = _mapFromBytes(data);
  return result;
}

(int method, Uint8List data) _mapFromFgRequest(_fgRequest from) {
  final method = from.method;
  final data = _mapToBytes(from.data);
  return (method, data);
}

_fgResponse _mapToFgResponse(Uint8List data, String? error) {
  final result = ffi.Struct.create<_fgResponse>();
  result.data = _mapFromBytes(data);
  result.error = _mapFromError(error);
  return result;
}

(Uint8List data, String? error) _mapFromFgResponse(_fgResponse from) {
  final data = _mapToBytes(from.data);
  final error = _mapToError(from.error);
  return (data, error);
}

Uint8List _mapToBytes(_fgData from) {
  if (from.data == ffi.nullptr) return Uint8List(0);
  final data = from.data.cast<ffi.Uint8>();
  final result = Uint8List.fromList(data.asTypedList(from.size));
  malloc.free(from.data);
  return result;
}

_fgData _mapFromBytes(Uint8List from) {
  final result = ffi.Struct.create<_fgData>();
  if (from.isEmpty) return result;
  final data = malloc<ffi.Uint8>(from.length);
  data.asTypedList(from.length).setAll(0, from);
  result.data = data.cast();
  result.size = from.length;
  return result;
}

String _mapToString(_fgData from) {
  final bytes = _mapToBytes(from);
  if (bytes.isEmpty) return '';
  return const Utf8Decoder().convert(bytes);
}

_fgData _mapFromString(String from) {
  final bytes = const Utf8Encoder().convert(from);
  return _mapFromBytes(bytes);
}

String? _mapToError(_fgData from) {
  if (from.data == ffi.nullptr) return null;
  return _mapToString(from);
}

_fgData _mapFromError(String? from) {
  if (from == null) {
    return ffi.Struct.create<_fgData>();
  }
  return _mapFromString(from);
}
