// Code generated by flutter_gopher. DO NOT EDIT.
// ignore_for_file: camel_case_types, non_constant_identifier_names, unused_element, unused_import
import 'dart:async';
import 'dart:convert';
import 'dart:ffi' as ffi;
import 'dart:typed_data';
import 'package:ffi/ffi.dart';
import 'package:flutter_gopher/flutter_gopher.dart';

abstract interface class {{.LibClassName}} {
  factory {{.LibClassName}}() => _{{.LibClassName}}();

  Uint8List? callGoMethod(String method, {Uint8List? data});
  Future<Uint8List?> callGoMethodAsync(String method, {Uint8List? data});
  Uint8List? callNativeMethod(String method, {Uint8List? data});
  Future<Uint8List?> callNativeMethodAsync(String method, {Uint8List? data});
}

final _lib = FgLoader('{{.LibName}}');
final _fgPacket Function(_fgPacket) _fgCallGoMethod = _lib
    .lookup<ffi.NativeFunction<_fgPacket Function(_fgPacket)>>(
        'fg_call_go_method')
    .asFunction();
final void Function(_fgPacket) _fgCallGoMethodAsync = _lib
    .lookup<ffi.NativeFunction<ffi.Void Function(_fgPacket)>>(
        'fg_call_go_method_async')
    .asFunction();
final _fgPacket Function(_fgPacket) _fgCallNativeMethod = _lib
    .lookup<ffi.NativeFunction<_fgPacket Function(_fgPacket)>>(
        'fg_call_native_method')
    .asFunction();
final void Function(_fgPacket) _fgCallNativeMethodAsync = _lib
    .lookup<ffi.NativeFunction<ffi.Void Function(_fgPacket)>>(
        'fg_call_native_method_async')
    .asFunction();
final _fgData Function() _fgEmptyData = _lib
    .lookup<ffi.NativeFunction<_fgData Function()>>('fg_empty_data')
    .asFunction();
final _fgPacket Function() _fgEmptyPacket = _lib
    .lookup<ffi.NativeFunction<_fgPacket Function()>>('fg_empty_packet')
    .asFunction();
final _fgPacket Function() _fgPacketLoop = _lib
    .lookup<ffi.NativeFunction<_fgPacket Function()>>('fg_packet_loop')
    .asFunction();
final int Function() _fgNextPortId = _lib
    .lookup<ffi.NativeFunction<ffi.Int64 Function()>>('fg_next_port_id')
    .asFunction();

final class _{{.LibClassName}} implements {{.LibClassName}} {
  _{{.LibClassName}}() {
    FgLoop.once('{{.LibName}}', (_) {
      final result = _fgPacketLoop();
      FgAsync.sendGoResult(result.id, result);
      return true;
    });
  }

  @override
  Uint8List? callGoMethod(String method, {Uint8List? data}) {
    final packet = _mapToPacket(method, data);
    final c_result = _fgCallGoMethod(packet);
    final result = _mapFgDataToBytes(c_result.data);
    _freeFgPacket(c_result);
    return result;
  }

  @override
  Future<Uint8List?> callGoMethodAsync(String method, {Uint8List? data}) async {
    final packet = _mapToPacket(method, data);
    final c_result = await FgAsync.go<_fgPacket, _fgPacket>((params, portId) {
      params.id = portId;
      _fgCallGoMethodAsync(params);
    }, packet, _fgNextPortId());
    final result = _mapFgDataToBytes(c_result.data);
    _freeFgPacket(c_result);
    return result;
  }

  @override
  Uint8List? callNativeMethod(String method, {Uint8List? data}) {
    final packet = _mapToPacket(method, data);
    final c_result = _fgCallNativeMethod(packet);
    final result = _mapFgDataToBytes(c_result.data);
    _freeFgPacket(c_result);
    return result;
  }

  @override
  Future<Uint8List?> callNativeMethodAsync(String method,
      {Uint8List? data}) async {
    final packet = _mapToPacket(method, data);
    final c_result = await FgAsync.go<_fgPacket, _fgPacket>((params, portId) {
      params.id = portId;
      _fgCallNativeMethodAsync(params);
    }, packet, _fgNextPortId());
    final result = _mapFgDataToBytes(c_result.data);
    _freeFgPacket(c_result);
    return result;
  }
}

final class _fgData extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;
  @ffi.Int()
  external int size;
}

final class _fgPacket extends ffi.Struct {
  @ffi.Int64()
  external int id;
  external _fgData method;
  external _fgData data;
}

void _freeFgPacket(_fgPacket pakcet) {
  _freeFgData(pakcet.method);
  _freeFgData(pakcet.data);
}

void _freeFgData(_fgData value) {
  if (value.data != ffi.nullptr) {
    malloc.free(value.data);
    value.data = ffi.nullptr;
    value.size = 0;
  }
}

_fgPacket _mapToPacket(String method, Uint8List? data) {
  final result = _fgEmptyPacket();
  result.method = _mapFgDataFromString(method);
  result.data = _mapFgDataFromBytes(data);
  return result;
}

Uint8List? _mapFgDataToBytes(_fgData from) {
  if (from.data == ffi.nullptr) return null;
  final data = from.data.cast<ffi.Uint8>();
  return Uint8List.fromList(data.asTypedList(from.size));
}

_fgData _mapFgDataFromBytes(Uint8List? from) {
  final result = _fgEmptyData();
  if (from != null) {
    final data = malloc<ffi.Uint8>(from.length);
    data.asTypedList(from.length).setAll(0, from);
    result.data = data.cast();
    result.size = from.length;
  }
  return result;
}

String _mapFgDataToString(_fgData from) {
  final bytes = _mapFgDataToBytes(from);
  if (bytes == null) return '';
  return const Utf8Decoder().convert(bytes);
}

_fgData _mapFgDataFromString(String from) {
  final bytes = const Utf8Encoder().convert(from);
  return _mapFgDataFromBytes(bytes);
}
