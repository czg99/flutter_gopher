package {{.PackageName}}

import com.sun.jna.Library
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import java.nio.charset.StandardCharsets

/**
 * Interface for FgBridge delegate to handle method calls
 */
interface FgBridgeDelegate {
    fun methodHandle(method: String, data: ByteArray?): ByteArray?
}

@Structure.FieldOrder("data", "size")
private open class FgData private constructor(): Structure() {
    class ByValue : FgData(), Structure.ByValue

    @JvmField
    var data: Pointer? = null

    @JvmField
    var size: Int = 0
}

@Structure.FieldOrder("method", "data")
private open class FgPacket private constructor() : Structure() {
    class ByValue : FgPacket(), Structure.ByValue
    class ByReference : FgPacket(), Structure.ByReference

    @JvmField
    var method: FgData.ByValue = FgData.ByValue()

    @JvmField
    var data: FgData.ByValue = FgData.ByValue()
}

private interface BridgeLib : Library {
    fun fg_call_go_method(packet: FgPacket.ByValue): FgPacket.ByValue
    fun fg_init_method_handle(handle: FgMethodHandleCallback)
}

private interface FgMethodHandleCallback : com.sun.jna.Callback {
    fun invoke(packet: FgPacket.ByValue, result: FgPacket.ByReference)
}

class FgBridge private constructor() {
    companion object {
        @Volatile
        private var instance: FgBridge? = null

        @JvmStatic
        fun sharedInstance(): FgBridge {
            return instance ?: synchronized(this) {
                instance ?: FgBridge().also {
                    instance = it
                }
            }
        }
    }

    private val bridgeLib: BridgeLib = Native.load("{{.LibName}}", BridgeLib::class.java)

    private var methodHandle: FgMethodHandleCallback

    var delegate: FgBridgeDelegate? = null

    init {
        methodHandle = object : FgMethodHandleCallback {
            override fun invoke(packet: FgPacket.ByValue, result: FgPacket.ByReference) {
                methodHandle(packet, result)
            }
        }
        bridgeLib.fg_init_method_handle(methodHandle)
    }

    private fun freeFgData(value: FgData) {
        if (value.data != null) {
            Native.free(Pointer.nativeValue(value.data))
            value.data = null
            value.size = 0
        }
    }

    private fun mapFgDataFromBytes(from: ByteArray?): FgData.ByValue {
        val result = FgData.ByValue()
        if (from != null) {
            val memory = Pointer(Native.malloc(from.size.toLong()))
            memory.write(0, from, 0, from.size)
            result.data = memory
            result.size = from.size
        }
        return result
    }

    private fun mapFgDataToBytes(from: FgData): ByteArray? {
        if (from.data == null) return null
        return from.data!!.getByteArray(0, from.size)
    }

    private fun mapFgDataFromString(from: String): FgData.ByValue {
        val bytes = from.toByteArray(Charsets.UTF_8)
        return mapFgDataFromBytes(bytes)
    }

    private fun mapFgDataToString(from: FgData): String {
        val bytes = mapFgDataToBytes(from) ?: return ""
        return String(bytes, StandardCharsets.UTF_8)
    }

    private fun methodHandle(packet: FgPacket.ByValue, result: FgPacket.ByReference) {
        val method = mapFgDataToString(packet.method)
        val data = mapFgDataToBytes(packet.data)
        freeFgData(packet.data)

        val handleData = delegate?.methodHandle(method, data)

        result.method = packet.method
        result.data = mapFgDataFromBytes(handleData)
    }

    fun callGoMethod(method: String, data: ByteArray? = null): ByteArray? {
        if (method.isEmpty()) return null

        val packet = FgPacket.ByValue()
        packet.method = mapFgDataFromString(method)
        packet.data = mapFgDataFromBytes(data)

        val cResult = bridgeLib.fg_call_go_method(packet)

        val result = mapFgDataToBytes(cResult.data)
        freeFgData(cResult.method)
        freeFgData(cResult.data)
        return result
    }
}
