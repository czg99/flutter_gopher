// Code generated by flutter_gopher. DO NOT EDIT.
package bridge

/*
#include "include/bridge.h"
*/
import "C"
import (
	"errors"
	"fmt"
	"unsafe"
)

func callNativeMethod(method string, data []byte) ([]byte, error) {
	if fgNativeMethodHandle == nil {
		return nil, fmt.Errorf("call native method: %s, error: native method handle not init", method)
	}
	request := mapToFgRequest(method, data)
	response := C.FgResponse{}
	C.call_fg_native_method_handle(fgNativeMethodHandle, request, &response)
	return mapFromFgResponse(response)
}

func callDartMethod(method string, data []byte) {
	if global_port == 0 {
		return
	}
	request := mapToFgRequest(method, data)
	fg_call_dart_method_{{.Timestamp}}(request)
}

//export fg_empty_data_{{.Timestamp}}
func fg_empty_data_{{.Timestamp}}() C.FgData {
	return C.FgData{}
}

//export fg_empty_request_{{.Timestamp}}
func fg_empty_request_{{.Timestamp}}() C.FgRequest {
	return C.FgRequest{}
}

//export fg_empty_response_{{.Timestamp}}
func fg_empty_response_{{.Timestamp}}() C.FgResponse {
	return C.FgResponse{}
}

var global_port C.int64_t = 0

//export fg_init_dart_api_{{.Timestamp}}
func fg_init_dart_api_{{.Timestamp}}(api unsafe.Pointer, port C.int64_t) {
	init_dart_api(api)
	global_port = port
}

var fgNativeMethodHandle C.FgNativeMethodHandle = nil

//export fg_init_native_method_handle_{{.Timestamp}}
func fg_init_native_method_handle_{{.Timestamp}}(handle C.FgNativeMethodHandle) {
	fgNativeMethodHandle = handle
}

//export fg_call_dart_method_{{.Timestamp}}
func fg_call_dart_method_{{.Timestamp}}(request C.FgRequest) {
	if global_port == 0 {
		freeFgData(&request.method)
		freeFgData(&request.data)
		return
	}
	sendToPort(global_port, unsafe.Pointer(cValueToPtr(request)))
}

//export fg_call_go_method_{{.Timestamp}}
func fg_call_go_method_{{.Timestamp}}(request C.FgRequest) C.FgResponse {
	method, data := mapFromFgRequest(request)
	result, err := callGoMethod(method, data)
	return mapToFgResponse(result, err)
}

//export fg_call_go_method_async_{{.Timestamp}}
func fg_call_go_method_async_{{.Timestamp}}(port C.int64_t, request C.FgRequest) {
	go func() {
		response := fg_call_go_method_{{.Timestamp}}(request)
		sendToPort(port, unsafe.Pointer(cValueToPtr(response)))
	}()
}

//export fg_call_native_method_{{.Timestamp}}
func fg_call_native_method_{{.Timestamp}}(request C.FgRequest) C.FgResponse {
	response := C.FgResponse{}
	if fgNativeMethodHandle == nil {
		method, _ := mapFromFgRequest(request)
		response.error = mapFgDataFromString(fmt.Sprintf("call native method: %s, error: native method handle not init", method))
		return response
	}

	C.call_fg_native_method_handle(fgNativeMethodHandle, request, &response)
	return response
}

//export fg_call_native_method_async_{{.Timestamp}}
func fg_call_native_method_async_{{.Timestamp}}(port C.int64_t, request C.FgRequest) {
	go func() {
		response := fg_call_native_method_{{.Timestamp}}(request)
		sendToPort(port, unsafe.Pointer(cValueToPtr(response)))
	}()
}

//export fg_enforce_binding_{{.Timestamp}}
func fg_enforce_binding_{{.Timestamp}}() {
	var ptr uintptr
	ptr ^= uintptr(unsafe.Pointer(C.fg_empty_data_{{.Timestamp}}))
	ptr ^= uintptr(unsafe.Pointer(C.fg_empty_request_{{.Timestamp}}))
	ptr ^= uintptr(unsafe.Pointer(C.fg_empty_response_{{.Timestamp}}))
	ptr ^= uintptr(unsafe.Pointer(C.fg_init_dart_api_{{.Timestamp}}))
	ptr ^= uintptr(unsafe.Pointer(C.fg_init_native_method_handle_{{.Timestamp}}))
	ptr ^= uintptr(unsafe.Pointer(C.fg_call_dart_method_{{.Timestamp}}))
	ptr ^= uintptr(unsafe.Pointer(C.fg_call_go_method_{{.Timestamp}}))
	ptr ^= uintptr(unsafe.Pointer(C.fg_call_go_method_async_{{.Timestamp}}))
	ptr ^= uintptr(unsafe.Pointer(C.fg_call_native_method_{{.Timestamp}}))
	ptr ^= uintptr(unsafe.Pointer(C.fg_call_native_method_async_{{.Timestamp}}))
}

func mapFromFgRequest(from C.FgRequest) (string, []byte) {
	method := mapFgDataToString(from.method)
	data := mapFgDataToBytes(from.data)
	return method, data
}

func mapToFgRequest(method string, data []byte) C.FgRequest {
	return C.FgRequest{
		method: mapFgDataFromString(method),
		data:   mapFgDataFromBytes(data),
	}
}

func mapFromFgResponse(from C.FgResponse) ([]byte, error) {
	data := mapFgDataToBytes(from.data)
	err := mapFgDataToError(from.error)
	return data, err
}

func mapToFgResponse(data []byte, err error) C.FgResponse {
	response := C.FgResponse{
		data: mapFgDataFromBytes(data),
	}
	if err != nil {
		response.error = mapFgDataFromError(err)
	}
	return response
}

func mapFgDataFromString(from string) C.FgData {
	return mapFgDataFromBytes([]byte(from))
}

func mapFgDataToString(from C.FgData) string {
	data := mapFgDataToBytes(from)
	if data == nil {
		return ""
	}
	return string(data)
}

func mapFgDataFromError(from error) C.FgData {
	if from == nil {
		return C.FgData{}
	}
	return mapFgDataFromString(from.Error())
}

func mapFgDataToError(from C.FgData) error {
	data := mapFgDataToBytes(from)
	if data == nil {
		return nil
	}
	return errors.New(string(data))
}

func mapFgDataFromBytes(from []byte) C.FgData {
	if from == nil {
		return C.FgData{}
	}
	data := C.CBytes(from)
	size := C.int(len(from))
	return C.FgData{
		data: data,
		size: size,
	}
}

func mapFgDataToBytes(from C.FgData) []byte {
	if from.data == nil {
		return nil
	}
	defer freeFgData(&from)
	return C.GoBytes(unsafe.Pointer(from.data), C.int(from.size))
}

func cValueToPtr[T any](value T) *T {
	size := unsafe.Sizeof(value)
	data := C.malloc(C.size_t(size))
	*(*T)(data) = value
	return (*T)(data)
}

func freeFgData(value *C.FgData) {
	if value != nil && value.data != nil {
		C.free(value.data)
		value.data = nil
		value.size = 0
	}
}
