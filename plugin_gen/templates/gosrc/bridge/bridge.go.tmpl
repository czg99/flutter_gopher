// Code generated by flutter_gopher. DO NOT EDIT.
package bridge

/*
#include "include/bridge.h"
*/
import "C"
import (
	"errors"
	"sync"
	"unsafe"
	"{{.ProjectName}}/dartapi"
)

func callPlatformMethod(method int, data []byte) ([]byte, error) {
	if fgPlatformMethodHandle == nil {
		return nil, errors.New("init err: platform method handle not init")
	}
	request := mapToFgRequest(method, data)
	response := C.FgResponse{}
	C.call_fg_platform_method_handle(fgPlatformMethodHandle, request, &response)
	return mapFromFgResponse(response)
}

func callDartMethod(method int, data []byte) {
	if len(global_port) == 0 {
		return
	}
	request := mapToFgRequest(method, data)
	fg_call_dart_method_{{.Timestamp}}(request)
}

var global_port = make(map[int64]struct{})
var global_lock = sync.Mutex{}

//export fg_init_dart_api_{{.Timestamp}}
func fg_init_dart_api_{{.Timestamp}}(api unsafe.Pointer, port C.int64_t) {
	dartapi.InitDartApi(api)
	global_lock.Lock()
	defer global_lock.Unlock()
	global_port[int64(port)] = struct{}{}
}

var fgPlatformMethodHandle C.FgPlatformMethodHandle = nil

//export fg_init_platform_method_handle_{{.Timestamp}}
func fg_init_platform_method_handle_{{.Timestamp}}(handle C.FgPlatformMethodHandle) {
	fgPlatformMethodHandle = handle
}

//export fg_call_dart_method_{{.Timestamp}}
func fg_call_dart_method_{{.Timestamp}}(request C.FgRequest) {
	if len(global_port) == 0 {
		freeFgRequest(&request, true)
		return
	}
	global_lock.Lock()
	defer global_lock.Unlock()
	count := len(global_port)
	for port, _ := range global_port {
		value := request
		if (count > 1) {
			value = C.FgRequest {
				method: request.method,
				data: copyFgData(request.data),
			}
		}
		ptr := cValueToPtr(value)
		if suc := dartapi.SendToDartPort(port, unsafe.Pointer(ptr)); !suc {
			freeFgRequest(ptr, false)
			delete(global_port, port)
		}
		count--
	}
}

//export fg_call_go_method_{{.Timestamp}}
func fg_call_go_method_{{.Timestamp}}(request C.FgRequest) C.FgResponse {
	method, data := mapFromFgRequest(request)
	result, err := callGoMethod(method, data)
	return mapToFgResponse(result, err)
}

//export fg_call_go_method_async_{{.Timestamp}}
func fg_call_go_method_async_{{.Timestamp}}(port C.int64_t, request C.FgRequest) {
	go func() {
		response := fg_call_go_method_{{.Timestamp}}(request)
		ptr := cValueToPtr(response)
		if suc := dartapi.SendToDartPort(int64(port), unsafe.Pointer(ptr)); !suc {
			freeFgResponse(ptr, false)
		}
	}()
}

//export fg_call_platform_method_{{.Timestamp}}
func fg_call_platform_method_{{.Timestamp}}(request C.FgRequest) C.FgResponse {
	response := C.FgResponse{}
	if fgPlatformMethodHandle == nil {
		freeFgRequest(&request, true)
		response.error = mapFromString("init err: platform method handle not init")
		return response
	}

	C.call_fg_platform_method_handle(fgPlatformMethodHandle, request, &response)
	return response
}

//export fg_call_platform_method_async_{{.Timestamp}}
func fg_call_platform_method_async_{{.Timestamp}}(port C.int64_t, request C.FgRequest) {
	go func() {
		response := fg_call_platform_method_{{.Timestamp}}(request)
		ptr := cValueToPtr(response)
		if suc := dartapi.SendToDartPort(int64(port), unsafe.Pointer(ptr)); !suc {
			freeFgResponse(ptr, false)
		}
	}()
}

func mapFromFgRequest(from C.FgRequest) (int, []byte) {
	method := int(from.method)
	data := mapToBytes(from.data)
	return method, data
}

func mapToFgRequest(method int, data []byte) C.FgRequest {
	return C.FgRequest{
		method: C.int(method),
		data:   mapFromBytes(data),
	}
}

func mapFromFgResponse(from C.FgResponse) ([]byte, error) {
	data := mapToBytes(from.data)
	err := mapToError(from.error)
	return data, err
}

func mapToFgResponse(data []byte, err error) C.FgResponse {
	response := C.FgResponse{
		data: mapFromBytes(data),
	}
	if err != nil {
		response.error = mapFromError(err)
	}
	return response
}

func mapFromString(from string) C.FgData {
	return mapFromBytes([]byte(from))
}

func mapToString(from C.FgData) string {
	data := mapToBytes(from)
	if data == nil {
		return ""
	}
	return string(data)
}

func mapFromError(from error) C.FgData {
	if from == nil {
		return C.FgData{}
	}
	return mapFromString(from.Error())
}

func mapToError(from C.FgData) error {
	if from.data == nil {
		return nil
	}
	return errors.New(mapToString(from))
}

func mapFromBytes(from []byte) C.FgData {
	if len(from) == 0 {
		return C.FgData{}
	}
	data := C.CBytes(from)
	size := C.int(len(from))
	return C.FgData{
		data: data,
		size: size,
	}
}

func mapToBytes(from C.FgData) []byte {
	if from.data == nil {
		return nil
	}
	defer C.free(from.data)
	return C.GoBytes(unsafe.Pointer(from.data), C.int(from.size))
}

func freeFgRequest(value *C.FgRequest, freeInnerOnly bool) {
	C.free(value.data.data)
	if !freeInnerOnly {
		C.free(unsafe.Pointer(value))
	}
}

func freeFgResponse(value *C.FgResponse, freeInnerOnly bool) {
	C.free(value.data.data)
	C.free(value.error.data)
	if !freeInnerOnly {
		C.free(unsafe.Pointer(value))
	}
}

func copyFgData(src C.FgData) C.FgData {
	if src.data == nil || src.size <= 0 {
		return C.FgData{}
	}

	dstData := C.malloc(C.size_t(src.size))
	C.memcpy(dstData, src.data, C.size_t(src.size))
	return C.FgData{
		data: dstData,
		size: src.size,
	}
}

func cValueToPtr[T any](value T) *T {
	size := unsafe.Sizeof(value)
	data := C.malloc(C.size_t(size))
	*(*T)(data) = value
	return (*T)(data)
}

//export fg_bridge_binding_{{.Timestamp}}
func fg_bridge_binding_{{.Timestamp}}() {
	var ptr uintptr
	ptr ^= uintptr(unsafe.Pointer(C.fg_init_dart_api_{{.Timestamp}}))
	ptr ^= uintptr(unsafe.Pointer(C.fg_init_platform_method_handle_{{.Timestamp}}))
	ptr ^= uintptr(unsafe.Pointer(C.fg_call_dart_method_{{.Timestamp}}))
	ptr ^= uintptr(unsafe.Pointer(C.fg_call_go_method_{{.Timestamp}}))
	ptr ^= uintptr(unsafe.Pointer(C.fg_call_go_method_async_{{.Timestamp}}))
	ptr ^= uintptr(unsafe.Pointer(C.fg_call_platform_method_{{.Timestamp}}))
	ptr ^= uintptr(unsafe.Pointer(C.fg_call_platform_method_async_{{.Timestamp}}))
}
