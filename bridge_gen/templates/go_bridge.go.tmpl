{{$bridge := . -}}
// Code generated by flutter_gopher. DO NOT EDIT.
package main

import (
	"errors"
	"unsafe"
	"reflect"
	{{- if gt (len $bridge.Funcs) 0}}
	"fmt"
	"runtime/debug"
	{{- end}}

	. "{{$bridge.PkgPath}}"
)

/*
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h> 

{{range $obj := $bridge.Structs}}
struct {{$obj.CType}};
{{- end}}

typedef struct {
	void* data;
	bool* valid;
	int len;
} fg_array;

{{- define "generateCStruct"}}
{{- $obj := .obj}}
typedef struct {{if .withTag}}{{$obj.CType}} {{end}}{
	{{- range $field := $obj.Fields}}
	{{$field.CType}} {{$field.CName}};
	{{- end}}
	{{- if .isParams}}
	int64_t fg_port_id;
	{{- end}}
	{{- if .isResults}}
	void* fg_panic;
	{{- end}}
} {{$obj.CType}};
{{- end}}

{{- range $obj := $bridge.Structs}}
{{template "generateCStruct" makeMap "obj" $obj "withTag" true}}
{{- end}}

{{- range $fn := $bridge.Funcs}}
{{template "generateCStruct" makeMap "obj" $fn.Params "isParams" true}}
{{template "generateCStruct" makeMap "obj" $fn.Results "isResults" true}}
{{- end}}

#ifdef _WIN32
    #define DLLEXPORT __declspec(dllexport)
#else
    #define DLLEXPORT
#endif

{{- range $fn := $bridge.Funcs}}
extern DLLEXPORT {{$fn.Results.CType}} {{$fn.CType}}({{$fn.Params.CType}} params);
{{- end}}
*/
import "C"

// Required by cgo
func main() {}

{{- define "generateGoStruct"}}
type {{$.GoType}} struct {
	{{- range $field := $.Fields}}
	{{$field.GoName}} {{$field.GoType}}
	{{- end}}
}
{{- end}}

{{- range $fn := $bridge.Funcs}}
{{template "generateGoStruct" $fn.Params}}
{{template "generateGoStruct" $fn.Results}}
{{- end}}


{{range $fn := $bridge.Funcs}}
//export {{$fn.CType}}
func {{$fn.CType}}(params {{$fn.Params.GoCType}}) (result {{$fn.Results.GoCType}}) {
	defer func() {
		if r := recover(); r != nil {
			result.fg_panic = mapFromString(fmt.Sprintf("panic: %v\n%s\n", r, string(debug.Stack())))
		}
	}()

	{{- if gt (len $fn.Params.Fields) 0}}
	go_params := mapTo{{$fn.Params.MapName}}(params)
	{{- end}}

	{{range $i, $field := $fn.Results.Fields}}{{if gt $i 0}}, {{end -}} {{$field.GoName}} {{- end}}
	{{- if gt (len $fn.Results.Fields) 0}} := {{end -}}
	{{$fn.GoType}}(
		{{- range $i, $field := $fn.Params.Fields}} {{- if gt $i 0}}, {{end}}go_params.{{$field.GoName}}{{end -}}
	)

	{{- if gt (len $fn.Results.Fields) 0}}
	go_result := {{$fn.Results.GoType}}{
		{{- range $i, $field := $fn.Results.Fields}}{{- if gt $i 0}}, {{end}}{{$field.GoName}}: {{$field.GoName}}{{end -}}
	}
	return mapFrom{{$fn.Results.MapName}}(go_result)
	{{- else}}
	return
	{{- end}}
}
{{end}}

{{- define "generateMap"}}
{{- $obj := .}}
{{- $fields := $obj.Fields}}
func mapTo{{$obj.MapName}}(from {{$obj.GoCType}}) (result {{$obj.GoType}}) {
	{{- range $field := $fields}}
		{{- if $field.IsSlice }}
			{{- "\n	"}}result.{{$field.GoName}} = mapFromFgArray(from.{{$field.CName}},
			{{- "\n		"}}func(c {{$field.InnerMost.GoCType}}) {{$field.Type.Inner.GoType}} {
				{{- if eq $field.InnerMost.MapName ""}}
				{{- "\n			"}}value := {{$field.InnerMost.GoType}}(c)
				{{- else}}
				{{- "\n			"}}value := mapTo{{$field.InnerMost.MapName}}(c)
				{{- end}}
				{{- if $field.Type.IsInnerPtr}}
				{{- "\n			"}}return valueToPtr(value)
				{{- else}}
				{{- "\n			"}}return value
				{{- end}}
			{{- "\n		"}}})
		{{- else if $field.IsPtr }}
		{{- "\n	"}}if from.{{$field.CName}} != nil {
			{{- if eq $field.InnerMost.MapName ""}}
			{{- "\n		"}}result.{{$field.GoName}} = valueToPtr({{$field.InnerMost.GoType}}(cValueFromPtr(from.{{$field.CName}})))
			{{- else}}
			{{- "\n		"}}result.{{$field.GoName}} = valueToPtr(mapTo{{$field.InnerMost.MapName}}(cValueFromPtr(from.{{$field.CName}})))
			{{- end}}
		{{- "\n	"}}}
		{{- else}}
			{{- if eq $field.MapName ""}}
			{{- "\n	"}}result.{{$field.GoName}} = {{$field.GoType}}(from.{{$field.CName}})
			{{- else}}
			{{- "\n	"}}result.{{$field.GoName}} = mapTo{{$field.MapName}}(from.{{$field.CName}})
			{{- end}}
		{{- end}}
	{{- end}}
	return
}

func mapFrom{{$obj.MapName}}(from {{$obj.GoType}}) (result {{$obj.GoCType}}) {
	{{- range $field := $fields}}
		{{- if $field.IsSlice }}
			{{- "\n	"}}result.{{$field.CName}} = mapToFgArray(from.{{$field.GoName}}, 
			{{- "\n		"}}func(g {{$field.Type.Inner.GoType}}) {{$field.InnerMost.GoCType}} {
				{{- if $field.Type.IsInnerPtr}}
				{{- "\n			"}}value := valueFromPtr(g)
				{{- else}}
				{{- "\n			"}}value := g
				{{- end}}
				{{- if eq $field.InnerMost.MapName ""}}
				{{- "\n			"}}return {{$field.InnerMost.GoCType}}(value)
				{{- else}}
				{{- "\n			"}}return mapFrom{{$field.InnerMost.MapName}}(value)
				{{- end}}
			{{- "\n		"}}},
			{{- "\n		"}}func(g {{$field.Type.Inner.GoType}}) bool {
				{{- if $field.Type.IsInnerPtr}}
				{{- "\n			"}}return g == nil
				{{- else}}
				{{- "\n			"}}return false
				{{- end}}
			{{- "\n		"}}})
		{{- else if $field.IsPtr}}
		{{- "\n	"}}if from.{{$field.GoName}} != nil {
			{{- if eq $field.InnerMost.MapName ""}}
			{{- "\n		"}}result.{{$field.CName}} = cValueToPtr({{$field.InnerMost.GoCType}}(valueFromPtr(from.{{$field.GoName}})))
			{{- else}}
			{{- "\n		"}}result.{{$field.CName}} = cValueToPtr(mapFrom{{$field.InnerMost.MapName}}(valueFromPtr(from.{{$field.GoName}})))
			{{- end}}
		{{- "\n	"}}}
		{{- else}}
			{{- if eq $field.MapName ""}}
			{{- "\n	"}}result.{{$field.CName}} = {{$field.GoCType}}(from.{{$field.GoName}})
			{{- else}}
			{{- "\n	"}}result.{{$field.CName}} = mapFrom{{$field.MapName}}(from.{{$field.GoName}})
			{{- end}}
		{{- end}}
	{{- end}}
	return
}
{{end}}

{{- range $obj := $bridge.Structs}}
{{template "generateMap" $obj}}
{{- end}}

{{- range $fn := $bridge.Funcs}}
{{template "generateMap" $fn.Params}}
{{template "generateMap" $fn.Results}}
{{- end}}

func mapToError(from unsafe.Pointer) error {
	if from == nil {
		return nil
	}
	result := C.GoString((*C.char)(from))
	C.free(from)
	return errors.New(result)
}

func mapFromError(from error) unsafe.Pointer {
	if from == nil {
		return nil
	}
	return unsafe.Pointer(C.CString(from.Error()))
}

func mapToString(from unsafe.Pointer) string {
	result := C.GoString((*C.char)(from))
	C.free(from)
	return result
}

func mapFromString(from string) unsafe.Pointer {
	return unsafe.Pointer(C.CString(from))
}

func cValueToPtr[T any](value T) *T {
	size := unsafe.Sizeof(value)
	data := C.malloc(C.size_t(size))
	*(*T)(data) = value
	return (*T)(data)
}

func cValueFromPtr[T any](ptr *T) T {
	value := *ptr
	C.free(unsafe.Pointer(ptr))
	return value
}

func valueToPtr[T any](value T) *T {
	return &value
}

func valueFromPtr[T any](ptr *T) T {
	if ptr == nil {
		var zero T
		return zero
	}
	return *ptr
}

func valuesToPtrs[T any](values []T) []*T {
	if len(values) == 0 {
		return nil
	}

	result := make([]*T, 0, len(values))
	for _, v := range values {
		result = append(result, &v)
	}
	return result
}

func valuesFromPtrs[T any](ptrs []*T) []T {
	if len(ptrs) == 0 {
		return nil
	}

	result := make([]T, len(ptrs))
	for i, ptr := range ptrs {
		if ptr != nil {
			result[i] = *ptr
		}
	}
	return result
}

func mapFromFgArray[T any, C_T any](from C.fg_array, converter func(C_T) T) []T {
	if from.len <= 0 {
		return nil
	}
	length := int(from.len)
	result := make([]T, length)

	var cValue C_T
	size := unsafe.Sizeof(cValue)
	data := from.data
	valid := from.valid

	for i := 0; i < length; i++ {
		valuePtr := (*C_T)(unsafe.Pointer(uintptr(data) + uintptr(i)*size))
		isValid := true
		if valid != nil {
			isValid = bool(*(*C.bool)(unsafe.Pointer(uintptr(unsafe.Pointer(valid)) + uintptr(i)*unsafe.Sizeof(C.bool(false)))))
		}
		
		if isValid {
			result[i] = converter(*valuePtr)
		} else {
			var zero T
			result[i] = zero
		}
	}

	C.free(data)
	if valid != nil {
		C.free(unsafe.Pointer(valid))
	}
	return result
}

func mapToFgArray[T any, C_T any](from []T, converter func(T) C_T, isNil func(T) bool) C.fg_array {
	if len(from) == 0 {
		return C.fg_array{data: nil, valid: nil, len: 0}
	}

	isPointerType := reflect.TypeOf(from[0]).Kind() == reflect.Ptr

	var cValue C_T
	size := unsafe.Sizeof(cValue)
	data := C.malloc(C.size_t(size * uintptr(len(from))))
	length := C.int(len(from))

	var valid unsafe.Pointer = nil
	if isPointerType {
		valid = C.malloc(C.size_t(unsafe.Sizeof(C.bool(false)) * uintptr(len(from))))
	}

	for i, v := range from {
		valuePtr := (*C_T)(unsafe.Pointer(uintptr(data) + uintptr(i)*size))
		isValid := !isNil(v)

		if isPointerType {
			validPtr := (*C.bool)(unsafe.Pointer(uintptr(valid) + uintptr(i)*unsafe.Sizeof(C.bool(false))))
			*validPtr = C.bool(isValid)
		}
		
		if isValid {
			*valuePtr = converter(v)
		} else {
			var zero C_T
			*valuePtr = zero
		}
	}
	return C.fg_array{data: data, valid: (*C.bool)(valid), len: length}
}

//export enforce_binding
func enforce_binding() {
	var ptr uintptr
	{{- range $fn := $bridge.Funcs}}
	ptr ^= uintptr(unsafe.Pointer(C.{{$fn.CType}}))
	{{- end}}
}
