{{$bridge := . -}}
// Code generated by flutter_gopher. DO NOT EDIT.
package main

import (
	"errors"
	"unsafe"
	"time"
	"sync"
	"sync/atomic"
	{{- if gt (len $bridge.Funcs) 0}}
	"fmt"
	"runtime/debug"
	{{- end}}

	. "{{$bridge.PkgPath}}"
)

/*
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

{{range $obj := $bridge.Structs}}
struct {{$obj.CType}};
{{- end}}

typedef struct {
	int64_t port_id;
} fg_chan;

typedef struct {
	int64_t port_id;
	void* data;
} fg_result;

typedef struct {
	void* data;
	int length;
} fg_array;

{{- define "generateCStruct"}}
{{- $obj := .obj}}
typedef struct {{if .withTag}}{{$obj.CType}} {{end}}{
	{{- if or .isParams}}
	int64_t port_id;
	{{- end}}
	{{- range $field := $obj.Fields}}
	{{$field.CType}} {{$field.CName}};
	{{- end}}
	{{- if .isResults}}
	void* panic_err;
	{{- end}}
} {{$obj.CType}};
{{- end}}

{{- range $obj := $bridge.Structs}}
{{template "generateCStruct" makeMap "obj" $obj "withTag" true}}
{{- end}}

{{- range $fn := $bridge.Funcs}}
{{template "generateCStruct" makeMap "obj" $fn.Params "isParams" true}}
{{template "generateCStruct" makeMap "obj" $fn.Results "isResults" true}}
{{- end}}

#ifdef _WIN32
    #define DLLEXPORT __declspec(dllexport)
#else
    #define DLLEXPORT
#endif

extern DLLEXPORT fg_result fg_result_loop();
extern DLLEXPORT int64_t fg_next_port_id();
{{- range $fn := $bridge.Funcs}}
extern DLLEXPORT {{$fn.Results.CType}} {{$fn.CType}}({{$fn.Params.CType}} params);
{{- end}}
*/
import "C"

// If youâ€™ve defined it elsewhere, please delete this main function.
func main() {}

{{- define "generateGoStruct"}}
type {{$.GoType}} struct {
	{{- range $field := $.Fields}}
	{{$field.GoName}} {{$field.GoType}}
	{{- end}}
}
{{- end}}

{{- range $fn := $bridge.Funcs}}
{{template "generateGoStruct" $fn.Params}}
{{template "generateGoStruct" $fn.Results}}
{{- end}}

var resultChan = make(chan C.fg_result)

//export fg_result_loop 
func fg_result_loop() C.fg_result {
	select {
	case result := <- resultChan:
		return result
	case <- time.After(time.Second):
		return C.fg_result{}
	}
}

const minPortId int64 = 0xFF
const maxPortId int64 = 0xFFFFFFFFFFFF
var portMutex sync.Mutex
var nextPortId int64 = minPortId - 1

//export fg_next_port_id
func fg_next_port_id() C.int64_t {
	next := atomic.AddInt64(&nextPortId, 1)

	if next > maxPortId {
		portMutex.Lock()
		defer portMutex.Unlock()

		current := atomic.LoadInt64(&nextPortId)
		if current > maxPortId {
			atomic.StoreInt64(&nextPortId, minPortId)
			return C.int64_t(minPortId)
		} else {
			return C.int64_t(atomic.AddInt64(&nextPortId, 1))
		}
	}
	return C.int64_t(next)
}

{{range $fn := $bridge.Funcs}}
//export {{$fn.CType}}
func {{$fn.CType}}(params {{$fn.Params.GoCType}}) (result {{$fn.Results.GoCType}}) {
	defer func() {
		if r := recover(); r != nil {
			result.panic_err = mapFromString(fmt.Sprintf("panic: %v\n%s\n", r, string(debug.Stack())))
		}
	}()

	{{- if gt (len $fn.Params.Fields) 0}}
	go_params := mapTo{{$fn.Params.MapName}}(params)
	{{- end}}

	{{range $i, $field := $fn.Results.Fields}}{{if gt $i 0}}, {{end -}} {{$field.GoName}} {{- end}}
	{{- if gt (len $fn.Results.Fields) 0}} := {{end -}}
	{{$fn.GoType}}(
		{{- range $i, $field := $fn.Params.Fields}} {{- if gt $i 0}}, {{end}}go_params.{{$field.GoName}}{{end -}}
	)

	{{- if gt (len $fn.Results.Fields) 0}}
	go_result := {{$fn.Results.GoType}}{
		{{- range $i, $field := $fn.Results.Fields}}{{- if gt $i 0}}, {{end}}{{$field.GoName}}: {{$field.GoName}}{{end -}}
	}
	result = mapFrom{{$fn.Results.MapName}}(go_result)
	{{- end}}
	return
}

//export {{$fn.CType}}_async
func {{$fn.CType}}_async(params {{$fn.Params.GoCType}}) {
	go func() {
		result := {{$fn.CType}}(params)
		resultChan <- C.fg_result{port_id: params.port_id, data: unsafe.Pointer(cValueToPtr(result))}
	}()
}
{{end}}

{{- define "generateMap"}}
{{- $obj := .obj}}
{{- $fields := $obj.Fields}}
{{- if not .isResults}}
func mapTo{{$obj.MapName}}(from {{$obj.GoCType}}) (result {{$obj.GoType}}) {
	{{- range $field := $fields}}
	{{- if not $field.NeedMap}}
	result.{{$field.GoName}} = {{$field.GoType}}(from.{{$field.CName}})
	{{- else}}
	result.{{$field.GoName}} = mapTo{{$field.MapName}}(from.{{$field.CName}})
	{{- end}}
	{{- end}}
	return
}
{{end}}

{{- if not .isParams}}
func mapFrom{{$obj.MapName}}(from {{$obj.GoType}}) (result {{$obj.GoCType}}) {
	{{- range $field := $fields}}
	{{- if not $field.NeedMap}}
	result.{{$field.CName}} = {{$field.GoCType}}(from.{{$field.GoName}})
	{{- else}}
	result.{{$field.CName}} = mapFrom{{$field.MapName}}(from.{{$field.GoName}})
	{{- end}}
	{{- end}}
	return
}
{{end}}
{{end}}

{{- range $obj := $bridge.Structs}}
{{template "generateMap" makeMap "obj" $obj}}
{{- end}}

{{- range $fn := $bridge.Funcs}}
{{template "generateMap" makeMap "obj" $fn.Params "isParams" true}}
{{template "generateMap" makeMap "obj" $fn.Results "isResults" true}}
{{- end}}

{{range $obj := $bridge.Ptrs}}
func mapTo{{$obj.MapName}}(from {{$obj.GoCType}}) {{$obj.GoType}} {
	if from == nil {
		return nil
	}
	{{- if not $obj.Inner.NeedMap}}
	return goValueToPtr(({{$obj.Inner.GoType}})(cValueFromPtr(from)))
	{{- else}}
	return goValueToPtr(mapTo{{$obj.Inner.MapName}}(cValueFromPtr(from)))
	{{- end}}
}

func mapFrom{{$obj.MapName}}(from {{$obj.GoType}}) {{$obj.GoCType}} {
	if from == nil {
		return nil
	}
	{{- if not $obj.Inner.NeedMap}}
	return cValueToPtr(({{$obj.Inner.GoCType}})(goValueFromPtr(from)))
	{{- else}}
	return cValueToPtr(mapFrom{{$obj.Inner.MapName}}(goValueFromPtr(from)))
	{{- end}}
}
{{end}}

{{range $obj := $bridge.Slices}}
func mapTo{{$obj.MapName}}(from {{$obj.GoCType}}) {{$obj.GoType}} {
	if from.length <= 0 {
		return nil
	}

	var sizeType {{$obj.Inner.GoCType}}
	size := unsafe.Sizeof(sizeType)
	result := make({{$obj.GoType}}, from.length)
	for i := 0; i < int(from.length); i++ {
		cvalue := *(*{{$obj.Inner.GoCType}})(unsafe.Pointer(uintptr(from.data) + uintptr(i)*size))
		{{- if not $obj.Inner.NeedMap}}
		result[i] = ({{$obj.Inner.GoType}})(cvalue)
		{{- else}}
		result[i] = mapTo{{$obj.Inner.MapName}}(cvalue)
		{{- end}}
	}
	C.free(from.data)
	return result
}

func mapFrom{{$obj.MapName}}(from {{$obj.GoType}}) {{$obj.GoCType}} {
	if len(from) == 0 {
		return {{$obj.GoCType}}{}
	}

	var sizeType {{$obj.Inner.GoCType}}
	size := unsafe.Sizeof(sizeType)
	data := C.malloc(C.size_t(size * uintptr(len(from))))
	for i := 0; i < len(from); i++ {
		cvaluePtr := (*{{$obj.Inner.GoCType}})(unsafe.Pointer(uintptr(data) + uintptr(i)*size))
		{{- if not $obj.Inner.NeedMap}}
		*cvaluePtr = ({{$obj.Inner.GoCType}})(from[i])
		{{- else}}
		*cvaluePtr = mapFrom{{$obj.Inner.MapName}}(from[i])
		{{- end}}
	}
	return {{$obj.GoCType}}{data: data, length: C.int(len(from))}
}
{{end}}

{{range $obj := $bridge.Chans}}
func mapTo{{$obj.MapName}}(from {{$obj.GoCType}}) {{$obj.GoType}} {
	return mapToChan(from, func(value {{$obj.Inner.GoType}}) {{$obj.Inner.GoCType}} {
		{{- if not $obj.Inner.NeedMap}}
		return ({{$obj.Inner.GoCType}})(value)
		{{- else}}
		return mapFrom{{$obj.Inner.MapName}}(value)
		{{- end}}
	})
}

func mapFrom{{$obj.MapName}}(from {{$obj.GoType}}) {{$obj.GoCType}} {
	return mapFromChan(from, func(value {{$obj.Inner.GoType}}) {{$obj.Inner.GoCType}} {
		{{- if not $obj.Inner.NeedMap}}
		return ({{$obj.Inner.GoCType}})(value)
		{{- else}}
		return mapFrom{{$obj.Inner.MapName}}(value)
		{{- end}}
	})
}
{{end}}

func mapToError(from unsafe.Pointer) error {
	if from == nil {
		return nil
	}
	result := C.GoString((*C.char)(from))
	C.free(from)
	return errors.New(result)
}

func mapFromError(from error) unsafe.Pointer {
	if from == nil {
		return nil
	}
	return unsafe.Pointer(C.CString(from.Error()))
}

func mapToString(from unsafe.Pointer) string {
	if from == nil {
		return ""
	}
	result := C.GoString((*C.char)(from))
	C.free(from)
	return result
}

func mapFromString(from string) unsafe.Pointer {
	return unsafe.Pointer(C.CString(from))
}

func cValueToPtr[T any](value T) *T {
	size := unsafe.Sizeof(value)
	data := C.malloc(C.size_t(size))
	*(*T)(data) = value
	return (*T)(data)
}

func cValueFromPtr[T any](ptr *T) T {
	value := *ptr
	C.free(unsafe.Pointer(ptr))
	return value
}

func goValueToPtr[T any](value T) *T {
	return &value
}

func goValueFromPtr[T any](ptr *T) T {
	if ptr == nil {
		var zero T
		return zero
	}
	return *ptr
}

func mapToChan[T any, CT any](port C.fg_chan, convert func(T) CT) chan T {
	c := make(chan T)
	chanLoop(port.port_id, c, convert)
	return c
}

func mapFromChan[T any, CT any](c <-chan T, convert func(T) CT) C.fg_chan {
	portId := fg_next_port_id()
	chanLoop(portId, c, convert)
	return C.fg_chan{port_id: portId}
}

func chanLoop[T any, CT any](portId C.int64_t, c <-chan T, convert func(T) CT) {
	go func() {
		for {
			result, ok := <-c
			if !ok {
				break
			}
			c_result := convert(result)
			resultChan <- C.fg_result{port_id: portId, data: unsafe.Pointer(cValueToPtr(c_result))}
		}
	}()
}

//export enforce_binding
func enforce_binding() {
	var ptr uintptr
	ptr ^= uintptr(unsafe.Pointer(C.fg_result_loop))
	ptr ^= uintptr(unsafe.Pointer(C.fg_next_port_id))
	{{- range $fn := $bridge.Funcs}}
	ptr ^= uintptr(unsafe.Pointer(C.{{$fn.CType}}))
	{{- end}}
}
