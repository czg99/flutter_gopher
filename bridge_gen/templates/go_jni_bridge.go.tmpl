{{$bridge := . -}}
// Code generated by flutter_gopher. DO NOT EDIT.
package main

import "C"
import (
	"unsafe"
    "log"
    {{- if gt (len $bridge.Funcs) 0}}
	"fmt"
	"runtime/debug"
	{{- end}}

	"github.com/timob/jnigi"
    . "{{$bridge.PkgPath}}"
)

{{- range $fn := $bridge.Funcs}}
//export {{$fn.GoJniType}}
func {{$fn.GoJniType}}(jenv unsafe.Pointer, jobj uintptr, params uintptr) (result uintptr) {
	env := jnigi.WrapEnv(jenv)
	defer env.DeleteGlobalRefCache()

    defer func() {
		if r := recover(); r != nil {
			resultObj, err := env.NewObject("{{$fn.Results.KotlinPackagePath}}")
			if err != nil {
                log.Fatalln(err)
                return
			}
            panicErr := jniMapFromString(env, fmt.Sprintf("panic: %v\n%s\n", r, string(debug.Stack())))
            defer env.DeleteLocalRef(panicErr)
			if err := resultObj.SetField(env, "panicErr", panicErr); err != nil {
                log.Fatalln(err)
                return
			}
            result = uintptr(resultObj.JObject())
		}
	}()

	{{- if gt (len $fn.Params.Fields) 0}}
    paramsObj := jnigi.WrapJObject(params, "{{$fn.Params.KotlinPackagePath}}", false)
	go_params := jniMapTo{{$fn.Params.MapName}}(env, paramsObj)
	{{- end}}

	{{range $i, $field := $fn.Results.Fields}}{{if gt $i 0}}, {{end -}} {{$field.GoName}} {{- end}}
	{{- if gt (len $fn.Results.Fields) 0}} := {{end -}}
	{{$fn.GoType}}(
		{{- range $i, $field := $fn.Params.Fields}} {{- if gt $i 0}}, {{end}}go_params.{{$field.GoName}}{{end -}}
	)

	go_result := {{$fn.Results.GoType}}{
		{{- range $i, $field := $fn.Results.Fields}}{{- if gt $i 0}}, {{end}}{{$field.GoName}}: {{$field.GoName}}{{end -}}
	}
	resultObj := jniMapFrom{{$fn.Results.MapName}}(env, go_result)
	return uintptr(resultObj.JObject())
}
{{- end}}


{{- define "generateMap"}}
{{- $obj := .obj}}
{{- $fields := $obj.Fields}}
{{- if not .isResults}}
func jniMapTo{{$obj.MapName}}(env *jnigi.Env, from *jnigi.ObjectRef) (result {{$obj.GoType}}) {
	{{- range $field := $fields}}

    {{- if not $field.NeedMap}}
    var {{$field.GoName}} {{$field.GoType}}
    if err := from.GetField(env, "{{$field.KotlinName}}", &{{$field.GoName}}); err != nil {
        panic(err)
    }
    {{- else}}
    {{$field.GoName}} := jnigi.NewObjectRef("{{$field.Type.KotlinPackagePath}}")
    defer env.DeleteLocalRef({{$field.GoName}})
    if err := from.GetField(env, "{{$field.KotlinName}}", {{$field.GoName}}); err != nil {
        panic(err)
    }
	{{- end}}

    {{- if not $field.NeedMap}}
    result.{{$field.GoName}} = {{$field.GoName}}
	{{- else}}
    result.{{$field.GoName}} = jniMapTo{{$field.MapName}}(env, {{$field.GoName}})
	{{- end}}

    {{- end}}
	return
}
{{end}}

{{- if not .isParams}}
func jniMapFrom{{$obj.MapName}}(env *jnigi.Env, from {{$obj.GoType}}) *jnigi.ObjectRef {
    result, err := env.NewObject("{{$obj.KotlinPackagePath}}")
    if err != nil {
        panic(err)
	}

	{{- range $field := $fields}}    

	{{- if not $field.NeedMap}}
    {{$field.KotlinName}} := from.{{$field.GoName}}
	{{- else}}
    {{$field.KotlinName}} := jniMapFrom{{$field.MapName}}(env, from.{{$field.GoName}})
    defer env.DeleteLocalRef({{$field.KotlinName}})
	{{- end}}
    if err := result.SetField(env, "{{$field.KotlinName}}", {{$field.KotlinName}}); err != nil {
        panic(err)
	}
    {{- end}}

	return result
}
{{end}}
{{end}}

{{- range $obj := $bridge.Structs}}
{{template "generateMap" makeMap "obj" $obj}}
{{- end}}

{{- range $fn := $bridge.Funcs}}
{{template "generateMap" makeMap "obj" $fn.Params "isParams" true}}
{{template "generateMap" makeMap "obj" $fn.Results "isResults" true}}
{{- end}}

{{range $obj := $bridge.Ptrs}}
func jniMapTo{{$obj.MapName}}(env *jnigi.Env, from *jnigi.ObjectRef) {{$obj.GoType}} {
    if from.IsNil() {
        return nil
    }
    result := jniMapTo{{$obj.Inner.MapName}}(env, from)
    return goValueToPtr(result)
}

func jniMapFrom{{$obj.MapName}}(env *jnigi.Env, from {{$obj.GoType}}) *jnigi.ObjectRef {
	if from == nil {
		return jnigi.NewObjectRef("{{$obj.KotlinPackagePath}}")
	}
    return jniMapFrom{{$obj.Inner.MapName}}(env, goValueFromPtr(from))
}
{{end}}


{{range $obj := $bridge.Slices}}
func jniMapTo{{$obj.MapName}}(env *jnigi.Env, from *jnigi.ObjectRef) {{$obj.GoType}} {
	var size int
	if err := from.CallMethod(env, "size", &size); err != nil {
		panic(err)
	}

	result := make({{$obj.GoType}}, size)
	for i := 0; i < size; i++ {
		value := jnigi.NewObjectRef("java/lang/Object")
		if err := from.CallMethod(env, "get", value, i); err != nil {
			panic(err)
		}
		obj := jniMapTo{{$obj.Inner.MapName}}(env, value)
		env.DeleteLocalRef(value)
		result[i] = obj
	}
	return result
}

func jniMapFrom{{$obj.MapName}}(env *jnigi.Env, from {{$obj.GoType}}) *jnigi.ObjectRef {
	result, err := env.NewObject("{{$obj.KotlinPackagePath}}", len(from))
	if err != nil {
		panic(err)
	}
	if len(from) == 0 {
		return result
	}
	for _, item := range from {
		obj := jniMapFrom{{$obj.Inner.MapName}}(env, item).Cast("java/lang/Object")
		var suc bool
		err := result.CallMethod(env, "add", &suc, obj)
		if err != nil {
			panic(err)
		}
	}
    return result
}
{{end}}

{{range $obj := $bridge.Basics}}
func jniMapTo{{$obj.MapName}}(env *jnigi.Env, from *jnigi.ObjectRef) (result {{$obj.GoType}}) {
	if from == nil || from.IsNil() {
		return
	}
	if err := from.CallMethod(env, "{{$obj.KotlinGetValue}}", &result); err != nil {
		panic(err)
	}
	return
}

func jniMapFrom{{$obj.MapName}}(env *jnigi.Env, from {{$obj.GoType}}) *jnigi.ObjectRef {
	result, err := env.NewObject("{{$obj.KotlinPackagePath}}", from)
	if err != nil {
		panic(err)
	}
	return result
}
{{end}}

func jniMapToString(env *jnigi.Env, from *jnigi.ObjectRef) string {
	if from == nil || from.IsNil() {
		return ""
	}
	var bytes []byte
	if err := from.CallMethod(env, "getBytes", &bytes); err != nil {
		log.Fatalln(err)
	}
	return string(bytes)
}

func jniMapFromString(env *jnigi.Env, from string) *jnigi.ObjectRef {
	result, err := env.NewObject("java/lang/String", []byte(from))
	if err != nil {
		log.Fatalln(err)
	}
	return result
}