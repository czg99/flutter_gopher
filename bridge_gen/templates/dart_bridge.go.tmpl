{{$bridge := . -}}
// Code generated by flutter_gopher. DO NOT EDIT.
// ignore_for_file: camel_case_types, non_constant_identifier_names, unused_element, unused_import
import 'dart:async';
import 'dart:ffi' as ffi;
import 'package:ffi/ffi.dart';
import 'package:flutter_gopher/flutter_gopher.dart';
export 'package:flutter_gopher/chan.dart';

typedef Error = String?;

abstract interface class {{$bridge.DartClassName}} {
  factory {{$bridge.DartClassName}}() => _{{$bridge.DartClassName}}();
{{range $fn := $bridge.Funcs}}
  {{$fn.DartResultType}} {{$fn.DartType}}(
    {{- range $i, $param := $fn.Params.Fields}}
    {{- if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}
    {{- end -}}
  );
  Future<{{$fn.DartResultType}}> {{$fn.DartType}}DartAsync(
    {{- range $i, $param := $fn.Params.Fields}}
    {{- if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}
    {{- end -}}
  );
  Future<{{$fn.DartResultType}}> {{$fn.DartType}}GoAsync(
    {{- range $i, $param := $fn.Params.Fields}}
    {{- if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}
    {{- end -}}
  );
{{end -}}
}

final _lib = FgLoader('{{$bridge.LibName}}');
{{- range $fn := $bridge.Funcs}}
final {{$fn.Results.DartCType}} Function({{$fn.Params.DartCType}}) {{$fn.DartCType}} = _lib
    .lookup<ffi.NativeFunction<{{$fn.Results.DartCType}} Function({{$fn.Params.DartCType}})>>('{{$fn.CType}}')
    .asFunction();
final void Function({{$fn.Params.DartCType}}) {{$fn.DartCType}}GoAsync = _lib
    .lookup<ffi.NativeFunction<ffi.Void Function({{$fn.Params.DartCType}})>>('{{$fn.CType}}_async')
    .asFunction();
{{- end}}
final _fgResult Function() _fgResultLoop = _lib
    .lookup<ffi.NativeFunction<_fgResult Function()>>('fg_result_loop')
    .asFunction();
final int Function() _fgNextPortId = _lib
    .lookup<ffi.NativeFunction<ffi.Int64 Function()>>('fg_next_port_id')
    .asFunction();

final class _{{$bridge.DartClassName}} implements {{$bridge.DartClassName}} {
  _{{$bridge.DartClassName}}() {
    FgLoop.once('{{$bridge.LibName}}', (_) {
      final result = _fgResultLoop();
      FgAsync.sendGoResult(result.port_id, result.data);
      return true;
    });
  }

{{range $fn := $bridge.Funcs}}
  {{$fn.Params.DartCType}} _{{$fn.DartType}}CParams(
    {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}{{end -}}
  ) {
    final dart_params = {{$fn.Params.DartType}}(
      {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartName}}: {{$param.DartName}}{{end -}}
    );
    return _mapFrom{{$fn.Params.MapName}}(dart_params);
  }

  {{$fn.DartResultType}} _{{$fn.DartType}}Result(String funcName, {{$fn.Results.DartCType}} c_result) {
    if (c_result.panic_err != ffi.nullptr) {
      final err = _mapToError(c_result.panic_err);
      throw FgPanic('{{$bridge.LibName}}', funcName, err!);
    }

    {{- if gt (len $fn.Results.Fields) 0}}
    final dart_result = _mapTo{{$fn.Results.DartType}}(c_result);
    {{- end}}
    {{- if $fn.HasErr}}
    if (dart_result.err != null) {
      throw FgError('{{$bridge.LibName}}', funcName, dart_result.err!);
    }
    {{- end}}

    {{- if gt $fn.ResultCount 1}}
    return dart_result;
    {{- else if eq $fn.ResultCount 1}}
    return dart_result.{{(index $fn.Results.Fields 0).DartName}};
    {{- end}}
  }

  @override
  {{$fn.DartResultType}} {{$fn.DartType}}(
    {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}{{end -}}
  ) {
    final c_params = _{{$fn.DartType}}CParams(
      {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartName}}{{end -}}
    );
    final c_result = {{$fn.DartCType}}(c_params);
    return _{{$fn.DartType}}Result('{{$fn.DartType}}', c_result);
  }

  @override
  Future<{{$fn.DartResultType}}> {{$fn.DartType}}DartAsync(
    {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}{{end -}}
  ) {
    final c_params = _{{$fn.DartType}}CParams(
      {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartName}}{{end -}}
    );
    return FgAsync.dart((params) {
      final c_result = {{$fn.DartCType}}(c_params);
      return _{{$fn.DartType}}Result('{{$fn.DartType}}DartAsync', c_result);
    }, c_params);
  }

  @override
  Future<{{$fn.DartResultType}}> {{$fn.DartType}}GoAsync(
    {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}{{end -}}
  ) async {
    final c_params = _{{$fn.DartType}}CParams(
      {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartName}}{{end -}}
    );
    final data = await FgAsync.go((params, portId) {
      params.port_id = portId;
      {{$fn.DartCType}}GoAsync(params);
    }, c_params, _fgNextPortId());

    if (data == ffi.nullptr) {
      throw FgPanic('{{$bridge.LibName}}', '{{$fn.DartType}}GoAsync', 'result is null');
    }

    final c_result = data.cast<{{$fn.Results.DartCType}}>()[0];
    final result = _{{$fn.DartType}}Result('{{$fn.DartType}}GoAsync', c_result);
    calloc.free(data);
    return result;
  }
{{end -}}
}

final class _fgChan extends ffi.Struct {
  @ffi.Int64()
  external int port_id;
}

final class _fgResult extends ffi.Struct {
  @ffi.Int64()
  external int port_id;
  external ffi.Pointer<ffi.Void> data;
}

final class _fgArray extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;
  @ffi.Int()
  external int length;
}

{{- define "generateClass"}}
{{- $obj := .obj}}
final class {{$obj.DartType}} {
{{- range $field := $obj.Fields}}
  {{$field.DartType}} {{$field.DartName}};
{{- end}}
  {{$obj.DartType}}(
    {{- if gt (len $obj.Fields) 0 -}}{
    {{- range $i, $field := $obj.Fields -}}
    {{if gt $i 0}}, {{end}}{{$field.DartType}}{{if ne $field.DartDefault "null"}}?{{end}} {{$field.DartName}}
    {{- end -}}
    }{{- end -}}
  )
  {{- if gt (len $obj.Fields) 0}} : {{end -}}
  {{- range $i, $field := $obj.Fields -}}
    {{- if gt $i 0}}, {{end -}}
    {{- if ne $field.DartDefault "null" -}}
    {{$field.DartName}} = {{$field.DartName}} ?? {{$field.DartDefault}}
    {{- else -}}
    {{$field.DartName}} = {{$field.DartName}}
    {{- end -}}
  {{- end}};

  @override
  String toString() => '{{$obj.DartType}}{
{{- range $i, $field := $obj.Fields -}}
{{if gt $i 0}}, {{end}}{{$field.DartName}}: ${{$field.DartName}}
{{- end -}} }';
}

final class {{$obj.DartCType}} extends ffi.Struct {
{{- if or .isParams}}
  @ffi.Int64()
  external int port_id;
{{- end}}
{{- range $field := $obj.Fields}}
  {{- if not $field.NeedMap}}
  @{{$field.DartCType}}()
  external {{$field.DartType}} {{$field.CName}};
  {{- else}}
  external {{$field.DartCType}} {{$field.CName}};
  {{- end}}
{{- end}}
{{- if .isResults}}
  external ffi.Pointer<ffi.Void> panic_err;
{{- end}}
}
{{- end}}

{{- range $obj := $bridge.Structs}}
{{template "generateClass" makeMap "obj" $obj}}
{{- end}}

{{- range $fn := $bridge.Funcs}}
{{template "generateClass" makeMap "obj" $fn.Params "isParams" true}}
{{template "generateClass" makeMap "obj" $fn.Results "isResults" true}}
{{- end}}

{{- define "generateMap"}}
{{- $obj := .obj}}
{{- if not .isParams}}
{{$obj.DartType}} _mapTo{{$obj.MapName}}({{$obj.DartCType}} from) {
  final result = {{$obj.DartType}}();
  {{- range $i, $field := $obj.Fields}}
  result.{{$field.DartName}} = {{if not $field.NeedMap}}from.{{$field.CName}}{{else}}_mapTo{{$field.MapName}}(from.{{$field.CName}}){{end}};
  {{- end}}
  return result;
}
{{- end}}

{{- if not .isResults}}
{{$obj.DartCType}} _mapFrom{{$obj.MapName}}({{$obj.DartType}} from) {
  final result = ffi.Struct.create<{{$obj.DartCType}}>();
  {{- range $field := $obj.Fields}}    
  result.{{$field.CName}} = {{if not $field.NeedMap}}from.{{$field.DartName}}{{else}}_mapFrom{{$field.MapName}}(from.{{$field.DartName}}){{end}};
  {{- end}}
  return result;
}
{{- end}}
{{- end}}

{{- range $obj := $bridge.Structs}}
{{template "generateMap" makeMap "obj" $obj}}
{{- end}}

{{- range $fn := $bridge.Funcs}}
{{template "generateMap" makeMap "obj" $fn.Params "isParams" true}}
{{template "generateMap" makeMap "obj" $fn.Results "isResults" true}}
{{- end}}

{{range $obj := $bridge.Ptrs}}
{{$obj.DartType}} _mapTo{{$obj.MapName}}({{$obj.DartCType}} from) {
  if (from == ffi.nullptr) return null;
  {{- if not $obj.Inner.NeedMap}}
  final result = from[0];
  {{- else}}
  final result = _mapTo{{$obj.Inner.MapName}}(from[0]);
  {{- end}}
  calloc.free(from);
  return result;
}

{{$obj.DartCType}} _mapFrom{{$obj.MapName}}({{$obj.DartType}} from) {
  if (from == null) return ffi.nullptr;
  {{- if not $obj.Inner.NeedMap}}
  final cValue = from;
  {{- else}}
  final cValue = _mapFrom{{$obj.Inner.MapName}}(from);
  {{- end}}
  final result = calloc<{{$obj.Inner.DartCType}}>();
  result[0] = cValue;
  return result;
}
{{end}}

{{range $obj := $bridge.Slices}}
{{$obj.DartType}} _mapTo{{$obj.MapName}}({{$obj.DartCType}} from) {
  if (from.length <= 0) return [];
  
  final data = from.data.cast<{{$obj.Inner.DartCType}}>();
  final result = List.generate(from.length, (i) =>
    {{- if not $obj.Inner.NeedMap}} data[i]
    {{- else}} _mapTo{{$obj.Inner.MapName}}(data[i])
    {{- end -}}
  );
  calloc.free(data);
  return result;
}

{{$obj.DartCType}} _mapFrom{{$obj.MapName}}({{$obj.DartType}} from) {
  final result = ffi.Struct.create<{{$obj.DartCType}}>();
  if (from.isEmpty) return result;
  
  final data = calloc<{{$obj.Inner.DartCType}}>(from.length);
  for (var i = 0; i < from.length; i++) {
    {{- if not $obj.Inner.NeedMap}}
    data[i] = from[i];
    {{- else}}
    data[i] = _mapFrom{{$obj.Inner.MapName}}(from[i]);
    {{- end}}
  }
  result.data = data.cast();
  result.length = from.length;
  return result;
}
{{end}}

{{range $obj := $bridge.Chans}}
{{$obj.Inner.DartType}} _mapPointerTo{{$obj.Inner.MapName}}(ffi.Pointer<ffi.Void> ptr) {
  if (ptr == ffi.nullptr) return {{$obj.Inner.DartDefault}};
  
  final cValue = ptr.cast<{{$obj.Inner.DartCType}}>();
  {{- if not $obj.Inner.NeedMap}}
  final dartValue = cValue[0];
  {{- else}}
  final dartValue = _mapTo{{$obj.Inner.MapName}}(cValue[0]);
  {{- end}}
  calloc.free(ptr);
  return dartValue;  
}

{{$obj.DartType}} _mapTo{{$obj.MapName}}({{$obj.DartCType}} from) {
  final result = {{$obj.DartType}}();
  result.setPortId(from.port_id);
  result.setPointerToDart(_mapPointerTo{{$obj.Inner.MapName}});
  return result;
}

{{$obj.DartCType}} _mapFrom{{$obj.MapName}}({{$obj.DartType}} from) {
  from.setPortId(_fgNextPortId());
  from.setPointerToDart(_mapPointerTo{{$obj.Inner.MapName}});
  final result = ffi.Struct.create<{{$obj.DartCType}}>();
  result.port_id = from.portId;
  return result;
}
{{end}}

String _mapToString(ffi.Pointer<ffi.Void> from) {
  if (from == ffi.nullptr) return '';
  final result = from.cast<Utf8>().toDartString();
  calloc.free(from);
  return result;
}

ffi.Pointer<ffi.Void> _mapFromString(String from) {
  return from.toNativeUtf8(allocator: calloc).cast();
}

Error _mapToError(ffi.Pointer<ffi.Void> from) {
  if (from == ffi.nullptr) return null;
  return _mapToString(from);
}

ffi.Pointer<ffi.Void> _mapFromError(Error from) {
  if (from == null) return ffi.nullptr;
  return _mapFromString(from);
}
