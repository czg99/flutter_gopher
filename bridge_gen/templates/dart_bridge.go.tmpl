{{$bridge := . -}}
// Code generated by flutter_gopher. DO NOT EDIT.
// ignore_for_file: camel_case_types, non_constant_identifier_names, unused_element
import 'dart:async';
import 'dart:ffi' as ffi;
import 'package:ffi/ffi.dart';
import 'package:flutter_gopher/flutter_gopher.dart';

typedef Error = String?;

abstract interface class {{$bridge.DartClassName}} {
  factory {{$bridge.DartClassName}}() => _{{$bridge.DartClassName}}();
{{range $fn := $bridge.Funcs}}
  {{$fn.DartResultType}} {{$fn.DartType}}(
    {{- range $i, $param := $fn.Params.Fields}}
    {{- if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}
    {{- end -}}
  );
  Future<{{$fn.DartResultType}}> {{$fn.DartType}}DartAsync(
    {{- range $i, $param := $fn.Params.Fields}}
    {{- if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}
    {{- end -}}
  );
  Future<{{$fn.DartResultType}}> {{$fn.DartType}}GoAsync(
    {{- range $i, $param := $fn.Params.Fields}}
    {{- if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}
    {{- end -}}
  );
{{end -}}
}

final _lib = FgLoader('{{$bridge.LibName}}');
{{- range $fn := $bridge.Funcs}}
final {{$fn.Results.DartCType}} Function({{$fn.Params.DartCType}}) {{$fn.DartCType}} = _lib
    .lookup<ffi.NativeFunction<{{$fn.Results.DartCType}} Function({{$fn.Params.DartCType}})>>('{{$fn.CType}}')
    .asFunction();
final void Function({{$fn.Params.DartCType}}) {{$fn.DartCType}}GoAsync = _lib
    .lookup<ffi.NativeFunction<ffi.Void Function({{$fn.Params.DartCType}})>>('{{$fn.CType}}_async')
    .asFunction();
{{- end}}
final _fgResult Function() _fgResultLoop = _lib
    .lookup<ffi.NativeFunction<_fgResult Function()>>('fg_result_loop')
    .asFunction();
final int Function() _fgNextPortId = _lib
    .lookup<ffi.NativeFunction<ffi.Int64 Function()>>('fg_next_port_id')
    .asFunction();

final class _{{$bridge.DartClassName}} implements {{$bridge.DartClassName}} {

  _{{$bridge.DartClassName}}() {
    FgLoop.once('{{$bridge.LibName}}', (_) {
      final result = _fgResultLoop();
      FgAsync.sendGoResult(result.portId, result.data);
      return true;
    });
  }

{{range $fn := $bridge.Funcs}}
  {{$fn.Params.DartCType}} _{{$fn.DartType}}CParams(
    {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}{{end -}}
  ) {
    final dart_params = {{$fn.Params.DartType}}(
      {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartName}}: {{$param.DartName}}{{end -}}
    );
    return _mapFrom{{$fn.Params.MapName}}(dart_params);
  }

  {{$fn.DartResultType}} _{{$fn.DartType}}Result(String funcName, {{$fn.Results.DartCType}} c_result) {
    if (c_result.fg_panic != ffi.nullptr) {
      final err = _mapToError(c_result.fg_panic);
      throw FgPanic('{{$bridge.LibName}}', funcName, err!);
    }

    {{- if gt (len $fn.Results.Fields) 0}}
    final dart_result = _mapTo{{$fn.Results.DartType}}(c_result);
    {{- end}}
    {{- if ne $fn.DartErrorName ""}}
    if (dart_result.{{$fn.DartErrorName}} != null) {
      throw FgError('{{$bridge.LibName}}', funcName, dart_result.{{$fn.DartErrorName}}!);
    }
    {{- end}}

    {{- if gt $fn.ResultCount 1}}
    return dart_result;
    {{- else if eq $fn.ResultCount 1}}
    return dart_result.{{(index $fn.Results.Fields 0).DartName}};
    {{- end}}
  }

  @override
  {{$fn.DartResultType}} {{$fn.DartType}}(
    {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}{{end -}}
  ) {
    final c_params = _{{$fn.DartType}}CParams(
      {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartName}}{{end -}}
    );
    final c_result = {{$fn.DartCType}}(c_params);
    return _{{$fn.DartType}}Result('{{$fn.DartType}}', c_result);
  }

  @override
  Future<{{$fn.DartResultType}}> {{$fn.DartType}}DartAsync(
    {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}{{end -}}
  ) {
    final c_params = _{{$fn.DartType}}CParams(
      {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartName}}{{end -}}
    );
    return FgAsync.dart((params) {
      final c_result = {{$fn.DartCType}}(c_params);
      return _{{$fn.DartType}}Result('{{$fn.DartType}}DartAsync', c_result);
    }, c_params);
  }

  @override
  Future<{{$fn.DartResultType}}> {{$fn.DartType}}GoAsync(
    {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}{{end -}}
  ) async {
    final c_params = _{{$fn.DartType}}CParams(
      {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartName}}{{end -}}
    );
    final data = await FgAsync.go((params, portId) {
      params.fg_port_id = portId;
      {{$fn.DartCType}}GoAsync(params);
    }, c_params, _fgNextPortId());

    if (data == ffi.nullptr) {
      throw FgPanic('{{$bridge.LibName}}', '{{$fn.DartType}}GoAsync', 'result is null');
    }

    final c_result = data.cast<{{$fn.Results.DartCType}}>()[0];
    final result = _{{$fn.DartType}}Result('{{$fn.DartType}}GoAsync', c_result);
    calloc.free(data);
    return result;
  }
{{end -}}
}

final class _fgResult extends ffi.Struct {
  @ffi.Int64()
  external int portId;
  external ffi.Pointer<ffi.Void> data;
}

final class _fgArray extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;
  external ffi.Pointer<ffi.Bool> valid;
  @ffi.Int()
  external int len;
}

{{- define "generateClass"}}
{{- $obj := .obj}}
final class {{$obj.DartType}} {
{{- range $field := $obj.Fields}}
  {{$field.DartType}} {{$field.DartName}};
{{- end}}

  {{$obj.DartType}}(
    {{- if gt (len $obj.Fields) 0 -}}{
    {{- range $i, $field := $obj.Fields -}}
    {{if gt $i 0}}, {{end}}{{$field.DartType}}{{if ne $field.DartDefault "null"}}?{{end}} {{$field.DartName}}
    {{- end -}}
    }{{- end -}}
  )
  {{- if gt (len $obj.Fields) 0}} : {{end -}}
  {{- range $i, $field := $obj.Fields -}}
    {{- if gt $i 0}}, {{end -}}
    {{- if ne $field.DartDefault "null" -}}
    {{$field.DartName}} = {{$field.DartName}} ?? {{$field.DartDefault}}
    {{- else -}}
    {{$field.DartName}} = {{$field.DartName}}
    {{- end -}}
  {{- end}};

  @override
  String toString() => '{{$obj.DartType}}{
{{- range $i, $field := $obj.Fields -}}
{{if gt $i 0}}, {{end}}{{$field.DartName}}: ${{$field.DartName}}
{{- end -}} }';
}

final class {{$obj.DartCType}} extends ffi.Struct {
{{- if or .isParams}}
  @ffi.Int64()
  external int fg_port_id;
{{- end}}
{{- range $field := $obj.Fields}}
  {{- if eq $field.MapName ""}}
    {{- "\n  "}}@{{$field.DartCType}}()
    {{- "\n  "}}external {{$field.DartType}} {{$field.CName}};
  {{- else}}
    {{- "\n  "}}external {{$field.DartCType}} {{$field.CName}};
  {{- end}}
{{- end}}
{{- if .isResults}}
  external ffi.Pointer<ffi.Void> fg_panic;
{{- end}}
}
{{- end}}

{{- range $obj := $bridge.Structs}}
{{template "generateClass" makeMap "obj" $obj}}
{{- end}}

{{- range $fn := $bridge.Funcs}}
{{template "generateClass" makeMap "obj" $fn.Params "isParams" true}}
{{template "generateClass" makeMap "obj" $fn.Results "isResults" true}}
{{- end}}

{{- define "generateMap"}}
{{- $obj := .obj}}
{{- if not .isParams}}
{{$obj.DartType}} _mapTo{{$obj.MapName}}({{$obj.DartCType}} from) {
  final result = {{$obj.DartType}}();
  {{- range $i, $field := $obj.Fields}}
    {{- if $field.IsSlice}}
      {{- "\n  "}}result.{{$field.DartName}} = _mapTo{{$field.MapName}}(from.{{$field.CName}});
    {{- else if $field.IsPtr}}
      {{- "\n  "}}result.{{$field.DartName}} = _mapTo{{$field.MapName}}(from.{{$field.CName}});
    {{- else}}
      {{- "\n  "}}result.{{$field.DartName}} = {{if eq $field.MapName ""}}from.{{$field.CName}}{{else}}_mapTo{{$field.MapName}}(from.{{$field.CName}}){{end}};
    {{- end}}
  {{- end}}
  return result;
}
{{- end}}

{{- if not .isResults}}
{{$obj.DartCType}} _mapFrom{{$obj.MapName}}({{$obj.DartType}} from) {
  final result = ffi.Struct.create<{{$obj.DartCType}}>();
  {{- range $field := $obj.Fields}}
    {{- if $field.IsSlice}}
      {{- "\n  "}}result.{{$field.CName}} = _mapFrom{{$field.MapName}}(from.{{$field.DartName}});
    {{- else if $field.IsPtr}}
      {{- "\n  "}}result.{{$field.CName}} = _mapFrom{{$field.MapName}}(from.{{$field.DartName}});
    {{- else}}
      {{- if eq $field.MapName ""}}
        {{- "\n  "}}result.{{$field.CName}} = from.{{$field.DartName}};
      {{- else }}
        {{- "\n  "}}result.{{$field.CName}} = _mapFrom{{$field.MapName}}(from.{{$field.DartName}});
      {{- end}}
    {{- end}}
  {{- end}}
  return result;
}
{{- end}}
{{- end}}

{{- range $obj := $bridge.Structs}}
{{template "generateMap" makeMap "obj" $obj}}
{{- end}}

{{- range $fn := $bridge.Funcs}}
{{template "generateMap" makeMap "obj" $fn.Params "isParams" true}}
{{template "generateMap" makeMap "obj" $fn.Results "isResults" true}}
{{- end}}

{{range $obj := $bridge.Ptrs}}
{{$obj.DartType}} _mapTo{{$obj.MapName}}({{$obj.DartCType}} from) {
  if (from == ffi.nullptr) return null;
  final cValue = from[0];
  {{- if eq $obj.InnerMost.MapName ""}}
  final result = cValue;
  {{- else}}
  final result = _mapTo{{$obj.InnerMost.MapName}}(cValue);
  {{- end}}
  calloc.free(from);
  return result;
}

{{$obj.DartCType}} _mapFrom{{$obj.MapName}}({{$obj.DartType}} from) {
  if (from == null) return ffi.nullptr;
  final cValue = {{if eq $obj.InnerMost.MapName ""}}from{{else}}_mapFrom{{$obj.InnerMost.MapName}}(from){{end}};
  final result = calloc<{{$obj.InnerMost.DartCType}}>();
  result[0] = cValue;
  return result;
}
{{end}}

{{range $obj := $bridge.Slices}}
{{$obj.DartType}} _mapTo{{$obj.MapName}}({{$obj.DartCType}} from) {
  if (from.len <= 0) return [];
  
  final valid = from.valid;
  final data = from.data.cast<{{$obj.InnerMost.DartCType}}>();
  final result = {{$obj.DartType}}.empty(growable: true);;
  for (var i = 0; i < from.len; i++) {
    {{- if $obj.Type.IsInnerPtr}}
    final isValid = valid != ffi.nullptr ? valid[i] : true;
    if (!isValid) {
      result.add(null);
      continue;
    }
    {{- end}}
    final cValue = data[i];
    {{- if eq $obj.InnerMost.MapName ""}}
    result.add(cValue);
    {{- else}}
    result.add(_mapTo{{$obj.InnerMost.MapName}}(cValue));
    {{- end}}
  }

  calloc.free(data);
  if (valid != ffi.nullptr) {
      calloc.free(valid);    
  }
  return result;
}

{{$obj.DartCType}} _mapFrom{{$obj.MapName}}({{$obj.DartType}} from) {
  final result = ffi.Struct.create<{{$obj.DartCType}}>();
  if (from.isEmpty) return result;
  
  final data = calloc<{{$obj.InnerMost.DartCType}}>(from.length);
  final valid = {{if $obj.Type.IsInnerPtr}}calloc<ffi.Bool>(from.length){{else}}ffi.nullptr{{end}};
  for (var i = 0; i < from.length; i++) {
    final value = from[i];
    {{- if $obj.Type.IsInnerPtr}}
    if (value == null) {
      valid[i] = false;
      continue;
    }
    valid[i] = true;
    {{- end}}
    {{- if eq $obj.InnerMost.MapName ""}}
    data[i] = value;
    {{- else}}
    data[i] = _mapFrom{{$obj.InnerMost.MapName}}(value);
    {{- end}}
  }
  
  result.data = data.cast();
  result.valid = valid;
  result.len = from.length;
  return result;
}
{{end}}

String _mapToString(ffi.Pointer<ffi.Void> from) {
  final result = from.cast<Utf8>().toDartString();
  calloc.free(from);
  return result;
}

ffi.Pointer<ffi.Void> _mapFromString(String from) {
  return from.toNativeUtf8(allocator: calloc).cast();
}

Error _mapToError(ffi.Pointer<ffi.Void> from) {
  if (from == ffi.nullptr) return null;
  return _mapToString(from);
}

ffi.Pointer<ffi.Void> _mapFromError(Error from) {
  if (from == null) return ffi.nullptr;
  return _mapFromString(from);
}