{{$bridge := . -}}
// Code generated by flutter_gopher. DO NOT EDIT.
package ffi

import (
	"errors"
	"unsafe"
	{{- if gt (len $bridge.Funcs) 0}}
	"fmt"
	{{- end}}

	"{{.ProjectName}}/dartapi"
	_ "{{$bridge.Module}}/mobileinit"
)

/*
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

{{range $obj := $bridge.Structs}}
struct {{$obj.CType}};
{{- end}}

typedef struct {
	void* data;
	int size;
} FgData;

{{- define "generateCStruct"}}
{{- $obj := .obj}}
typedef struct {{if .withTag}}{{$obj.CType}} {{end}}{
	{{- range $field := $obj.Fields}}
	{{$field.CType}} {{$field.CName}};
	{{- end}}
	{{- if .isResults}}
	FgData err;
	{{- end}}
} {{$obj.CType}};
{{- end}}

{{- range $obj := $bridge.Structs}}
{{template "generateCStruct" makeMap "obj" $obj "withTag" true}}
{{- end}}

{{- range $fn := $bridge.Funcs}}
{{- if $fn.HasParams}}
{{template "generateCStruct" makeMap "obj" $fn.Params "isParams" true}}
{{- end}}
{{template "generateCStruct" makeMap "obj" $fn.Results "isResults" true}}
{{- end}}

typedef void (*FgCallback)(void*);
static void call_fg_callback(FgCallback callback, void* result) {
	callback(result);
}

#ifdef _WIN32
    #define DLLEXPORT __declspec(dllexport)
#else
    #define DLLEXPORT __attribute__((visibility("default")))
#endif

{{- range $fn := $bridge.Funcs}}
extern DLLEXPORT {{$fn.Results.CType}} {{$fn.CType}}({{if $fn.HasParams}}{{$fn.Params.CType}} params{{end}});
{{- end}}
*/
import "C"

{{- define "generateGoStruct"}}
type {{.GoType}} struct {
	{{- range $field := .Fields}}
	{{$field.GoName}} {{$field.GoType}}
	{{- end}}
}
{{- end}}

{{- range $fn := $bridge.Funcs}}
{{- if $fn.HasParams}}
{{template "generateGoStruct" $fn.Params}}
{{- end}}
{{- if $fn.HasResults}}
{{template "generateGoStruct" $fn.Results}}
{{- end}}
{{- end}}

{{range $fn := $bridge.Funcs}}
//export {{$fn.CType}}
func {{$fn.CType}}({{if $fn.HasParams}}params {{$fn.Params.GoCType}}{{end}}) (result {{$fn.Results.GoCType}}) {
	defer func() {
		if r := recover(); r != nil {
			result.err = mapFromString(fmt.Sprintf("panic err: %v", r))
		}
	}()

	{{- if $fn.HasParams}}
	go_params := mapTo{{$fn.Params.MapName}}(params)
	{{- end}}

	{{range $i, $field := $fn.Results.Fields}}{{if gt $i 0}}, {{end -}} {{$field.GoName}} {{- end}}
	{{- if $fn.HasErr}}{{if $fn.HasResults}}, {{end}}err{{end}} 
	{{- if or $fn.HasResults $fn.HasErr}} := {{end -}}
	{{$fn.GoType}}(
		{{- range $i, $field := $fn.Params.Fields}} {{- if gt $i 0}}, {{end}}go_params.{{$field.GoName}}{{end -}}
	)
	{{- if $fn.HasErr}}
	if err != nil {
		result.err = mapFromString(err.Error())
		return
	}
	{{- end}}

	{{- if $fn.HasResults}}
	go_result := {{$fn.Results.GoType}}{
		{{- range $i, $field := $fn.Results.Fields}}{{- if gt $i 0}}, {{end}}{{$field.GoName}}: {{$field.GoName}}{{end -}}
	}
	result = mapFrom{{$fn.Results.MapName}}(go_result)
	{{- end}}
	return
}

//export {{$fn.CType}}_async
func {{$fn.CType}}_async(port C.int64_t{{if $fn.HasParams}}, params {{$fn.Params.GoCType}}{{end}}) {
	go func() {
		result := {{$fn.CType}}({{if $fn.HasParams}}params{{end}})
		ptr := unsafe.Pointer(cValueToPtr(result))
		if suc := dartapi.SendToDartPort(int64(port), ptr); !suc {
			{{- if $fn.HasResults}}
			mapTo{{$fn.Results.MapName}}(result)
			{{- end}}
			C.free(result.err.data)
			C.free(ptr)
		}
	}()
}

//export {{$fn.CType}}_callback
func {{$fn.CType}}_callback({{if $fn.HasParams}}params {{$fn.Params.GoCType}}, {{end}}callback C.FgCallback) {
	go func() {
		result := {{$fn.CType}}({{if $fn.HasParams}}params{{end}})
		C.call_fg_callback(callback, unsafe.Pointer(cValueToPtr(result)))
	}()
}
{{end}}

{{- define "generateMap"}}
{{- $obj := .obj}}
{{- $fields := $obj.Fields}}
func mapTo{{$obj.MapName}}(from {{$obj.GoCType}}) (result {{$obj.GoType}}) {
	{{- range $field := $fields}}
	{{- if not $field.NeedMap}}
	result.{{$field.GoName}} = {{$field.GoType}}(from.{{$field.CName}})
	{{- else}}
	result.{{$field.GoName}} = mapTo{{$field.MapName}}(from.{{$field.CName}})
	{{- end}}
	{{- end}}
	return
}

{{- if not .isParams}}
func mapFrom{{$obj.MapName}}(from {{$obj.GoType}}) (result {{$obj.GoCType}}) {
	{{- range $field := $fields}}
	{{- if not $field.NeedMap}}
	result.{{$field.CName}} = {{$field.GoCType}}(from.{{$field.GoName}})
	{{- else}}
	result.{{$field.CName}} = mapFrom{{$field.MapName}}(from.{{$field.GoName}})
	{{- end}}
	{{- end}}
	return
}
{{end}}
{{end}}

{{- range $obj := $bridge.Structs}}
{{template "generateMap" makeMap "obj" $obj}}
{{- end}}

{{- range $fn := $bridge.Funcs}}
{{- if $fn.HasParams}}
{{template "generateMap" makeMap "obj" $fn.Params "isParams" true}}
{{- end}}
{{- if $fn.HasResults}}
{{template "generateMap" makeMap "obj" $fn.Results "isResults" true}}
{{- end}}
{{- end}}

{{range $obj := $bridge.Ptrs}}
func mapTo{{$obj.MapName}}(from {{$obj.GoCType}}) {{$obj.GoType}} {
	if from == nil {
		return nil
	}
	{{- if not $obj.Inner.NeedMap}}
	return goValueToPtr(({{$obj.Inner.GoType}})(cValueFromPtr(from)))
	{{- else}}
	return goValueToPtr(mapTo{{$obj.Inner.MapName}}(cValueFromPtr(from)))
	{{- end}}
}

func mapFrom{{$obj.MapName}}(from {{$obj.GoType}}) {{$obj.GoCType}} {
	if from == nil {
		return nil
	}
	{{- if not $obj.Inner.NeedMap}}
	return cValueToPtr(({{$obj.Inner.GoCType}})(goValueFromPtr(from)))
	{{- else}}
	return cValueToPtr(mapFrom{{$obj.Inner.MapName}}(goValueFromPtr(from)))
	{{- end}}
}
{{end}}

{{range $obj := $bridge.Slices}}
func mapTo{{$obj.MapName}}(from {{$obj.GoCType}}) {{$obj.GoType}} {
	if from.size <= 0 {
		return nil
	}

	var sizeType {{$obj.Inner.GoCType}}
	size := unsafe.Sizeof(sizeType)
	result := make({{$obj.GoType}}, from.size)
	for i := 0; i < int(from.size); i++ {
		cvalue := *(*{{$obj.Inner.GoCType}})(unsafe.Pointer(uintptr(from.data) + uintptr(i)*size))
		{{- if not $obj.Inner.NeedMap}}
		result[i] = ({{$obj.Inner.GoType}})(cvalue)
		{{- else}}
		result[i] = mapTo{{$obj.Inner.MapName}}(cvalue)
		{{- end}}
	}
	C.free(from.data)
	return result
}

func mapFrom{{$obj.MapName}}(from {{$obj.GoType}}) {{$obj.GoCType}} {
	if len(from) == 0 {
		return {{$obj.GoCType}}{}
	}

	var sizeType {{$obj.Inner.GoCType}}
	size := unsafe.Sizeof(sizeType)
	data := C.malloc(C.size_t(size * uintptr(len(from))))
	for i := 0; i < len(from); i++ {
		cvaluePtr := (*{{$obj.Inner.GoCType}})(unsafe.Pointer(uintptr(data) + uintptr(i)*size))
		{{- if not $obj.Inner.NeedMap}}
		*cvaluePtr = ({{$obj.Inner.GoCType}})(from[i])
		{{- else}}
		*cvaluePtr = mapFrom{{$obj.Inner.MapName}}(from[i])
		{{- end}}
	}
	return {{$obj.GoCType}}{data: data, size: C.int(len(from))}
}
{{end}}

func mapFromString(from string) C.FgData {
	return mapFromBytes([]byte(from))
}

func mapToString(from C.FgData) string {
	data := mapToBytes(from)
	if data == nil {
		return ""
	}
	return string(data)
}

func mapFromError(from error) C.FgData {
	if from == nil {
		return C.FgData{}
	}
	return mapFromString(from.Error())
}

func mapToError(from C.FgData) error {
	data := mapToBytes(from)
	if data == nil {
		return nil
	}
	return errors.New(string(data))
}

func mapFromBytes(from []byte) C.FgData {
	if from == nil {
		return C.FgData{}
	}
	data := C.CBytes(from)
	size := C.int(len(from))
	return C.FgData{
		data: data,
		size: size,
	}
}

func mapToBytes(from C.FgData) []byte {
	if from.data == nil {
		return nil
	}
	defer C.free(from.data)
	return C.GoBytes(unsafe.Pointer(from.data), C.int(from.size))
}

func cValueToPtr[T any](value T) *T {
	size := unsafe.Sizeof(value)
	data := C.malloc(C.size_t(size))
	*(*T)(data) = value
	return (*T)(data)
}

func cValueFromPtr[T any](ptr *T) T {
	value := *ptr
	C.free(unsafe.Pointer(ptr))
	return value
}

func goValueToPtr[T any](value T) *T {
	return &value
}

func goValueFromPtr[T any](ptr *T) T {
	if ptr == nil {
		var zero T
		return zero
	}
	return *ptr
}

//export fg_ffi_binding
func fg_ffi_binding() {
	var ptr uintptr
	{{- range $fn := $bridge.Funcs}}
	ptr ^= uintptr(unsafe.Pointer(C.{{$fn.CType}}))
	{{- end}}
}
