{{$bridge := . -}}
// Code generated by flutter_gopher. DO NOT EDIT.
// ignore_for_file: camel_case_types, non_constant_identifier_names, unused_element, unused_import
import 'dart:async';
import 'dart:convert';
import 'dart:ffi' as ffi;
import 'dart:isolate';
import 'dart:typed_data';
import 'package:ffi/ffi.dart';
import '../bridge/loader.dart';

typedef FgError = String?;

class FgFfiException implements Exception {
  final String message;

  const FgFfiException(this.message);

  @override
  String toString() => 'FgFfiException: $message';
}

final class FgFfi {
  FgFfi._();
  static final _api = _FgFfi();

{{range $fn := $bridge.Funcs}}
  static {{$fn.DartResultType}} {{$fn.DartType}}(
    {{- range $i, $param := $fn.Params.Fields}}
    {{- if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}
    {{- end -}}
  ) => _api.{{$fn.DartType}}(
    {{- range $i, $param := $fn.Params.Fields}}
    {{- if gt $i 0}}, {{end}}{{$param.DartName}}
    {{- end -}}
  );
  static Future<{{$fn.DartResultType}}> {{$fn.DartType}}Async(
    {{- range $i, $param := $fn.Params.Fields}}
    {{- if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}
    {{- end -}}
  ) => _api.{{$fn.DartType}}Async(
    {{- range $i, $param := $fn.Params.Fields}}
    {{- if gt $i 0}}, {{end}}{{$param.DartName}}
    {{- end -}}
  );
{{end -}}
}

final _lib = FgLoader('{{$bridge.LibName}}');
{{- range $fn := $bridge.Funcs}}
final {{$fn.Results.DartCType}} Function({{if $fn.HasParams}}{{$fn.Params.DartCType}}{{end}}) {{$fn.DartCType}} = _lib
    .lookup<ffi.NativeFunction<{{$fn.Results.DartCType}} Function({{if $fn.HasParams}}{{$fn.Params.DartCType}}{{end}})>>('{{$fn.CType}}')
    .asFunction();
final void Function(int{{if $fn.HasParams}}, {{$fn.Params.DartCType}}{{end}}) {{$fn.DartCType}}Async = _lib
    .lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int{{if $fn.HasParams}}, {{$fn.Params.DartCType}}{{end}})>>('{{$fn.CType}}_async')
    .asFunction();
{{- end}}

final class _FgFfi {
  _FgFfi();

{{range $fn := $bridge.Funcs}}
  {{- if $fn.HasParams}}
  {{$fn.Params.DartCType}} _{{$fn.DartType}}CParams(
    {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}{{end -}}
  ) {
    final dart_params = {{$fn.Params.DartType}}(
      {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartName}}: {{$param.DartName}}{{end -}}
    );
    return _mapFrom{{$fn.Params.MapName}}(dart_params);
  }
  {{- end}}

  {{$fn.DartResultType}} _{{$fn.DartType}}Result({{$fn.Results.DartCType}} c_result) {
    if (c_result.err.data != ffi.nullptr) {
      final err = _mapToError(c_result.err);
      throw FgFfiException(err!);
    }

    {{- if $fn.HasResults}}
    final dart_result = _mapTo{{$fn.Results.DartType}}(c_result);
    {{- if gt $fn.ResultCount 1}}
    return dart_result;
    {{- else if eq $fn.ResultCount 1}}
    return dart_result.{{(index $fn.Results.Fields 0).DartName}};
    {{- end}}
    {{- end}}
  }

  {{$fn.DartResultType}} {{$fn.DartType}}(
    {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}{{end -}}
  ) {
    {{- if $fn.HasParams}}
    final c_params = _{{$fn.DartType}}CParams(
      {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartName}}{{end -}}
    );
    {{- end}}
    final c_result = {{$fn.DartCType}}({{if $fn.HasParams}}c_params{{end}});
    return _{{$fn.DartType}}Result(c_result);
  }

  Future<{{$fn.DartResultType}}> {{$fn.DartType}}Async(
    {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartType}} {{$param.DartName}}{{end -}}
  ) async {
    {{- if $fn.HasParams}}
    final c_params = _{{$fn.DartType}}CParams(
      {{- range $i, $param := $fn.Params.Fields}}{{if gt $i 0}}, {{end}}{{$param.DartName}}{{end -}}
    );
    {{- end}}
    final receive_port = ReceivePort();
    {{$fn.DartCType}}Async(receive_port.sendPort.nativePort{{if $fn.HasParams}}, c_params{{end}});

    final result_addr = await receive_port.first;
    final c_result_ptr = ffi.Pointer.fromAddress(result_addr).cast<{{$fn.Results.DartCType}}>();

    final result = _{{$fn.DartType}}Result(c_result_ptr[0]);
    malloc.free(c_result_ptr);
    return result;
  }
{{end -}}
}

{{- define "generateDartClass"}}
{{- $obj := .obj}}
final class {{$obj.DartType}} {
{{- range $field := $obj.Fields}}
  {{$field.DartType}} {{$field.DartName}};
{{- end}}
  {{$obj.DartType}}(
    {{- if gt (len $obj.Fields) 0 -}}{
    {{- range $i, $field := $obj.Fields -}}
    {{if gt $i 0}}, {{end}}{{$field.DartType}}{{if ne $field.DartDefault "null"}}?{{end}} {{$field.DartName}}
    {{- end -}}
    }{{- end -}}
  )
  {{- if gt (len $obj.Fields) 0}} : {{end -}}
  {{- range $i, $field := $obj.Fields -}}
    {{- if gt $i 0}}, {{end -}}
    {{- if ne $field.DartDefault "null" -}}
    {{$field.DartName}} = {{$field.DartName}} ?? {{$field.DartDefault}}
    {{- else -}}
    {{$field.DartName}} = {{$field.DartName}}
    {{- end -}}
  {{- end}};

  @override
  String toString() => '{{$obj.DartType}}{
{{- range $i, $field := $obj.Fields -}}
{{if gt $i 0}}, {{end}}{{$field.DartName}}: ${{$field.DartName}}
{{- end -}} }';
}
{{- end}}

{{- range $obj := $bridge.Structs}}
{{template "generateDartClass" makeMap "obj" $obj}}
{{- end}}

{{- range $fn := $bridge.Funcs}}
{{- if $fn.HasParams}}
{{template "generateDartClass" makeMap "obj" $fn.Params "isParams" true}}
{{- end}}
{{- if $fn.HasResults}}
{{template "generateDartClass" makeMap "obj" $fn.Results "isResults" true}}
{{- end}}
{{- end}}

final class _fgData extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;
  @ffi.Int()
  external int size;
}

{{- define "generateCClass"}}
{{- $obj := .obj}}
final class {{$obj.DartCType}} extends ffi.Struct {
{{- range $field := $obj.Fields}}
  {{- if not $field.NeedMap}}
  @{{$field.DartCType}}()
  external {{$field.DartType}} {{$field.CName}};
  {{- else}}
  external {{$field.DartCType}} {{$field.CName}};
  {{- end}}
{{- end}}
{{- if .isResults}}
  external _fgData err;
{{- end}}
}
{{- end}}

{{- range $obj := $bridge.Structs}}
{{template "generateCClass" makeMap "obj" $obj}}
{{- end}}

{{- range $fn := $bridge.Funcs}}
{{- if $fn.HasParams}}
{{template "generateCClass" makeMap "obj" $fn.Params "isParams" true}}
{{- end}}
{{template "generateCClass" makeMap "obj" $fn.Results "isResults" true}}
{{- end}}

{{- define "generateMap"}}
{{- $obj := .obj}}
{{- if not .isParams}}
{{$obj.DartType}} _mapTo{{$obj.MapName}}({{$obj.DartCType}} from) {
  final result = {{$obj.DartType}}();
  {{- range $i, $field := $obj.Fields}}
  result.{{$field.DartName}} = {{if not $field.NeedMap}}from.{{$field.CName}}{{else}}_mapTo{{$field.MapName}}(from.{{$field.CName}}){{end}};
  {{- end}}
  return result;
}
{{- end}}

{{- if not .isResults}}
{{$obj.DartCType}} _mapFrom{{$obj.MapName}}({{$obj.DartType}} from) {
  final result = ffi.Struct.create<{{$obj.DartCType}}>();
  {{- range $field := $obj.Fields}}    
  result.{{$field.CName}} = {{if not $field.NeedMap}}from.{{$field.DartName}}{{else}}_mapFrom{{$field.MapName}}(from.{{$field.DartName}}){{end}};
  {{- end}}
  return result;
}
{{- end}}
{{- end}}

{{- range $obj := $bridge.Structs}}
{{template "generateMap" makeMap "obj" $obj}}
{{- end}}

{{- range $fn := $bridge.Funcs}}
{{- if $fn.HasParams}}
{{template "generateMap" makeMap "obj" $fn.Params "isParams" true}}
{{- end}}
{{- if $fn.HasResults}}
{{template "generateMap" makeMap "obj" $fn.Results "isResults" true}}
{{- end}}
{{- end}}

{{range $obj := $bridge.Ptrs}}
{{$obj.DartType}} _mapTo{{$obj.MapName}}({{$obj.DartCType}} from) {
  if (from == ffi.nullptr) return null;
  {{- if not $obj.Inner.NeedMap}}
  final result = from[0];
  {{- else}}
  final result = _mapTo{{$obj.Inner.MapName}}(from[0]);
  {{- end}}
  malloc.free(from);
  return result;
}

{{$obj.DartCType}} _mapFrom{{$obj.MapName}}({{$obj.DartType}} from) {
  if (from == null) return ffi.nullptr;
  {{- if not $obj.Inner.NeedMap}}
  final cValue = from;
  {{- else}}
  final cValue = _mapFrom{{$obj.Inner.MapName}}(from);
  {{- end}}
  final result = malloc<{{$obj.Inner.DartCType}}>();
  result[0] = cValue;
  return result;
}
{{end}}

{{range $obj := $bridge.Slices}}
{{$obj.DartType}} _mapTo{{$obj.MapName}}({{$obj.DartCType}} from) {
  if (from.size <= 0) return [];
  
  final data = from.data.cast<{{$obj.Inner.DartCType}}>();
  final result = List.generate(from.size, (i) =>
    {{- if not $obj.Inner.NeedMap}} data[i]
    {{- else}} _mapTo{{$obj.Inner.MapName}}(data[i])
    {{- end -}}
  );
  malloc.free(data);
  return result;
}

{{$obj.DartCType}} _mapFrom{{$obj.MapName}}({{$obj.DartType}} from) {
  final result = ffi.Struct.create<{{$obj.DartCType}}>();
  if (from.isEmpty) return result;
  
  final data = malloc<{{$obj.Inner.DartCType}}>(from.length);
  for (var i = 0; i < from.length; i++) {
    {{- if not $obj.Inner.NeedMap}}
    data[i] = from[i];
    {{- else}}
    data[i] = _mapFrom{{$obj.Inner.MapName}}(from[i]);
    {{- end}}
  }
  result.data = data.cast();
  result.size = from.length;
  return result;
}
{{end}}

Uint8List? _mapToBytes(_fgData from) {
  if (from.data == ffi.nullptr) return null;
  final data = from.data.cast<ffi.Uint8>();
  final result = Uint8List.fromList(data.asTypedList(from.size));
  malloc.free(from.data);
  return result;
}

_fgData _mapFromBytes(Uint8List? from) {
  final result = ffi.Struct.create<_fgData>();
  if (from != null) {
    final data = malloc<ffi.Uint8>(from.length);
    data.asTypedList(from.length).setAll(0, from);
    result.data = data.cast();
    result.size = from.length;
  }
  return result;
}

String _mapToString(_fgData from) {
  final bytes = _mapToBytes(from);
  if (bytes == null) return '';
  return const Utf8Decoder().convert(bytes);
}

_fgData _mapFromString(String from) {
  final bytes = const Utf8Encoder().convert(from);
  return _mapFromBytes(bytes);
}

FgError _mapToError(_fgData from) {
  if (from.data == ffi.nullptr) return null;
  return _mapToString(from);
}

_fgData _mapFromError(FgError from) {
  if (from == null) {
    return ffi.Struct.create<_fgData>();
  }
  return _mapFromString(from);
}
